
{*************************************************************************************************************

    Module Name   : LTE_CALIBRATION_HIST

    Purpose       : The report allows the user to add/modify/display etc 
                    calibration records for any configured calibration type.
	            The entry point when adding calibration records is the
	            routine 'add_cal_record', which adds a record of the calibration type
   	            associated with the menu procedure number passed by default from the
                    menu to the routine (each calibration type, stored in inst_calib_types,
                    has an associated main menu procedure number)
                 

    Document Ref. : 

    Specification : 

****************************************************************************************************************
*MODIFICATION HISTORY
*====================
*
*SM     Module  Reference                     Date         Name           Description
*-----  ------  ----------------              -------      ---------      -------------------------------------
*2000R1  V1.0   Elan-Calibration SDS 0-1.doc  Oct 02       K Jacobs       Created
*2000R1  V1.0   Elan-Calibration SDS 0-1.doc  Oct 02       A Finnerty     Updates based on Elan Calibration 
                                                                          SDS 0-1.doc
*2000R1  V1.1   Change control		      May 03       AM Fanning	  Updated due to PQ findings in Elan
*2000R1  V1.2   Calibration Ammendments       JUN 04       E Henry        Added in service report field
*                                                                         Remove check on due calibration date
*                                                                         so modifications can occur CC2004-080
*
*2000R1 V1.3    Change Control 2004-252       Nov 04       E Henry        Allow history record to print correctly
* 9.2   V1.4    9.2 Upgrade                   Apr 08       A Finnerty     Bug fix in 9.2 upgrade
****************************************************************************************************************}

{ ------------------------------------------------------------------------------------------------------------- }


{ ------------------------------------------------------------------------------------------------------------- }


{

  INTRODUCTION
  This report is the skeleton for creating table maintainance routines.
  It is intended to be used with the simpler laboratory tables and
  user defined tables. The data entry screen generated will not support
  list type entry screens such as the component editor.

  The following functions will be provided by this report:

      Add/Modify, Display, Print, List, Remove/Unremove

  Reports to support tables are generated by another setup report which
  will copy this report into a supplied name and then allow modification
  of the copy for the table required. Once modified the functions
  generated can be tested from the generic menu.

  The fields displayed on the data entry screen are defined by entering
  values into parameters in this report.

  Once a report has been created then it can be tested using the generic
  menu provided as part of the setup environment.

  ASSOCIATED FILES
        $LABSETUP.RPF  - Setup Report.
        $LABTABLIB.RPF - Library Report containing main routines.
        $LTE_TEM.RPF   - Skeleton Lab Table Report.(This file)


  SETUP DETAILS
  To customise this report for a table a number of variables and
  arrays must be setup in this report. To assist in this a copy
  of the messages file (MESSAGES.PRN) and the structure file (STRUCTURE.TXT)
  will be required.

  The areas of the report to be modified are indicated by comments and
  all occurrences of **** must be replaced with the required values. Note
  that some variables have been given default values which may also require
  changing.

}

{ --------------------------------------------------------------------------- }

{ --------------- Initialization Statements : DO NOT CHANGE ----------------- }

SET NOTPROTECTED

ENABLE WINDOWS
SET NAME "DISPLAY/"



JOIN STANDARD_LIBRARY std_vgl
JOIN STANDARD_LIBRARY std_array
JOIN STANDARD_LIBRARY std_prompt
JOIN LIBRARY $LABTABLIB   { 1.4 }

JOIN LIBRARY $lib_utils
JOIN LIBRARY IMPRINT_CAL_REPORTS
JOIN LIBRARY INST_CALIB_REP_BGR


{ --------------------------------------------------------------------------- }
{ globals }
DECLARE menu    ARRAY menu  ARRAY_SIZE(0,4)
DECLARE operation
DECLARE routine_name
DECLARE parameter
DECLARE is_init                
DECLARE is_new_entry
DECLARE g_print_label


{
  MENUPROC 56, called in add_calibration, needs this block of code 
}

IF ( GLOBAL( "param_active" ) )

    parameter = ""
    
    PROMPT FOR operation
    
    routine_name = operation : "_option"
    
    IF ( vgl_validate_routine( GLOBAL( "current_library" ), routine_name ) )
    
        CALL_ROUTINE routine_name
                IN LIBRARY GLOBAL( "current_library" )
                USING parameter
                
    ELSE
    
        fatal_error( "Invalid operation " : operation )
        
    ENDIF
    
ELSE

    initialise_menu( menu )
    
    CALL_MENU OUT_OF menu AT 10,10

ENDIF

EXIT
{ ----------------------------------------------------------------------------------------------- }

ROUTINE initialise_menu
    (
            menu
    )

    DECLARE i    
    
    i = 1
    menu[i,1] = "*"
    menu[i,2] = "Calibration History"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Add Internal Calibration"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "add_internal"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Add External Calibration"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "add_external"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Add PQ Calibration"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "add_pq"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Add PM Calibration"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "add_pm"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Add"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "add_option"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Print"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "print_option"


    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "New Version"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "new_version_option"


    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Modify"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "modify_option"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Display"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "display_option"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Remove"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "remove_option"

    i = i + 1
    menu[i,1] = ""
    menu[i,2] = "Restore"
    menu[i,3] = GLOBAL( "current_library" )
    menu[i,4] = "restore_option"

    
    RETURN
    
ENDROUTINE



{ -------------------------- Table Setup Routine ---------------------------- }

ROUTINE table_setup

    DECLARE i
    
	ARRAY prompt_details	ARRAY_SIZE ( 0 , 8 )
	ARRAY fields_to_output  ARRAY_SIZE ( 0 )

{

	CHANGE : Specify the name of the table in <name_of_table>
                 eg   name_of_table = "HAZARD"

}

	name_of_table           =  "INST_CALIB_HIST"

{

	CHANGE : MANDATORY : Specify the text to be displayed at the top
                 of the data entry screen in <header_mess>.
                 Note that the text may be specified literally
                 eg   header_mess = "Hazard Data Entry Screen"
                 or may be extracted from the message file
                 eg   header_mess = GET MESSAGE(xyz)

}

	header_mess = GET_USER_MESSAGE ( "INST_CALIB_HIST_HEADER_MESS" , 1 )

{

	CHANGE : MANDATORY : Specify the text to be displayed at the bottom
                 of the data entry screen in <footer_mess> for the options
                 add , copy , modify but not display.
                 Note that the text may be specified literally
                 eg   footer_mess = "Press DO to Save / EXIT to Quit"
                 or may be extracted from the message file
                 eg   footer_mess = GET MESSAGE(xyz)

}

	footer_mess = "****"

{

	CHANGE : MANDATORY : Specify the text to be displayed at the bottom
                 of the data entry screen in <display_footer_mess> for the
		 display option.
                 Note that the text may be specified literally
                 eg   footer_mess = "Press EXIT to Quit"
                 or may be extracted from the message file
                 eg   footer_mess = GET MESSAGE(xyz)

}

	display_footer_mess = "****"

{

	CHANGE : MANDATORY : Specify the names of the fields and the
                 text associated with each field to be displayed on the
                 screen.
                 For each field the field name is stored in an element
                 of array <prompt_details> with an index of FIELD_NAME_POSITION
                 and the message stored with an index of MESSAGE_POSITION.
                 This array will require expanding for the total number
		 of fields required on the screen.

                 e.g
		prompt_details [ 1 , MESSAGE_POSITION    ] = "Group Name"
        	prompt_details [ 1 , FIELD_NAME_POSITION ] = "GROUP_ID"

		prompt_details [ 1 , MESSAGE_POSITION    ] = "Hazard Label Text"
		prompt_details [ 1 , FIELD_NAME_POSITION ] = "LABEL_TEXT"

		prompt_details [ 1 , MESSAGE_POSITION    ] = "Description"
		prompt_details [ 1 , FIELD_NAME_POSITION ] = "DESCRIPTION"

		prompt_details [ 1 , MESSAGE_POSITION    ] = "Modifiable Entry"
		prompt_details [ 1 , FIELD_NAME_POSITION ] = "MODIFIABLE"

                The text may be specified literally as shown above
                or extracted from the message file using GET MESSAGE

}

    i = 0
    
    i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_GROUP" , 1 )
    prompt_details[i, FIELD_NAME_POSITION ] = "GROUP_ID"

    i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_DATE_CALIBRATED" , 1 )

    {Modification due to Calibration PQ Findings}
    {20-05-03 AMF				}

    IF ( operation = "add_ident" )  OR  ( operation = "new_version" ) {OR ( operation = "modify_ident")}

    
    {EH  JUN 2004 Calibration ammendments  }
    {Stops initialising the screen for mods}

		IF(operation = "modify_ident") THEN
			is_init = TRUE
		ENDIF

     {EH end of mods  JUN 2004}

        prompt_details [ i , TYPE_POSITION       ] = "ROUTINE"
        prompt_details [ i , LIBRARY_POSITION    ] = global ( "current_library" )
        prompt_details [ i , ROUTINE_POSITION    ] = "prompt_date_calibrated"

        { will be adding new entry - need to know this later so flag it  }
	IF(operation <> "modify_ident")

        is_new_entry = TRUE
	ENDIF
     {end mod AMF 20-05-03}
    ELSE

        prompt_details[i, FIELD_NAME_POSITION ] = "DATE_CALIBRATED"

    ENDIF


    i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_STATUS" , 1 )
    prompt_details[i, FIELD_NAME_POSITION ] = "STATUS"

    i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_PERFORMED_BY" , 1 )
    prompt_details[i, FIELD_NAME_POSITION ] = "EXTERNAL_BY"

    i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_ACTUAL_CAL_DUE" , 1 )

    IF ( operation = "add_ident" )
         OR ( operation = "new_version" ) 
        prompt_details [ i , TYPE_POSITION       ] = "ROUTINE"
        prompt_details [ i , LIBRARY_POSITION    ] = global ( "current_library" )
        prompt_details [ i , ROUTINE_POSITION    ] = "prompt_actual_calib_due"

        {  new entry - flag it   }
	        is_new_entry = TRUE
	
    ELSE

        prompt_details[i, FIELD_NAME_POSITION ] = "ACTUAL_CALIB_DUE"

    ENDIF


    i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_CALC_CALIB_DUE" , 1 )
    prompt_details[i, FIELD_NAME_POSITION ] = "CALCULATED_CALIB_DUE"
    prompt_details [ i , TYPE_POSITION       ] = "DISPLAY"

    i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_COMMENTS" , 1 )
    prompt_details[i, FIELD_NAME_POSITION ] = "COMMENTS"
{EH start of mod 08-JUN-2004}
     i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_SERVICE_REP" , 1 )
    prompt_details[i, FIELD_NAME_POSITION ] = "SERVICE_REPORT"

{EH End of Mod 80-JUN-2004}
    i = i + 1
    prompt_details[i, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "INST_CALIB_HIST_MODIFIABLE" , 1 )
    prompt_details[i, FIELD_NAME_POSITION ] = "MODIFIABLE"





{
	move the comments braces to allow use of these statements
}
{

		prompt_details [ 2 , MESSAGE_POSITION    ] = "****"
		prompt_details [ 2 , FIELD_NAME_POSITION ] = "****"

		prompt_details [ 3 , MESSAGE_POSITION    ] = "****"
		prompt_details [ 3 , FIELD_NAME_POSITION ] = "****"

		prompt_details [ 4 , MESSAGE_POSITION    ] = "****"
		prompt_details [ 4 , FIELD_NAME_POSITION ] = "****"

}

{

	CHANGE : Specify the name of the table to be displayed on the screen
                 in <displayed_name_of_table>. This is useful for foreign
                 language support.
                 eg   displayed_name_of_table = "Hazard"

}

	displayed_name_of_table    = GET_USER_MESSAGE ( "INST_CALIB_HIST_DISPLAYED_TABLE_NAME" , 1 )

{

	CHANGE : Specify the name of the directory where text files are stored
                 which may contain descriptive information in <directory> and
                 the extension of the file in <extn>. If there is no associated
                 text file then these should be set to EMPTY.
                 For instance the hazard table.
                 eg   directory = "SMP$TEXTFILES"
                      extn = "HAZ"
                 or
                      directory = EMPTY
                      extn = EMPTY

}

	directory = EMPTY
	extn = EMPTY

{

	CHANGE : MANDATORY : Specify the text to be displayed when prompting
                 for an identifier.
                 Note that the text may be specified literally
                 eg   input_mess  = "Enter Hazard ID : "
                 or may be extracted from the message file
                 eg   input_mess = GET MESSAGE(xyz)

}

	input_mess = GET_USER_MESSAGE ( "INST_CALIB_HIST_INPUT_MESSAGE" , 1 )

{

	CHANGE : OPTIONAL : Specify default unique key value for new additions
		to the table - the default values for any new entry to the
		table will be copied from this entry in the database.
                Set <default_value> to be empty to ignore this feature.

		e.g
		  default_value = "DEFAULT"

}

	default_value = EMPTY

{

	CHANGE : MANDATORY : Specify the number of the fields to appear
                on the output generated by the list option.
                For each field to be output on the list an element of the array
		<fields_to_output> should contain a number corresponding to
		the position of that field in the array <prompt_details>.
		This array can be of any size from zero elements to the
		size of the arrays <prompt_details>.

		e.g
		  fields_to_output [ 1 ] = 1
		  fields_to_output [ 2 ] = 4
		  fields_to_output [ 3 ] = 3

}

    i = 1
    WHILE ( i <= size_of_array( prompt_details ) )
    
    	fields_to_output[i]  = i
        i = i + 1

    ENDWHILE        

{

	move the comments braces to allow use of these statements

}

{
	fields_to_output [ 2 ]  = "****"
	fields_to_output [ 3 ]  = "****"
	fields_to_output [ 4 ]  = "****"
	fields_to_output [ 5 ]  = "****"
	fields_to_output [ 6 ]  = "****"
	fields_to_output [ 7 ]  = "****"
	fields_to_output [ 8 ]  = "****"
	fields_to_output [ 9 ]  = "****"

}

{

	CHANGE : OPTIONAL : Specify a special action to happen on pressing the
			     <select> key.

                CHARACTER_POSITION index contains a character for the menu item.
                TITLE_POSITION     index contains a title for the menu item.
                LIBRARY_POSITION   index contains the library to call.
                ROUTINE_POSITION   index contains a routine in the library.

	eg

	special_actions_report [ 1 , CHARACTER_POSITION ] = "*"
	special_actions_report [ 1 , TITLE_POSITION     ] = "Analysis Options"

	special_actions_report [ 2 , CHARACTER_POSITION ] = "1"
	special_actions_report [ 2 , TITLE_POSITION     ] = "1 Analysis Components"
	special_actions_report [ 2 , LIBRARY_POSITION   ] = "$COMP_EDIT"
	special_actions_report [ 2 , ROUTINE_POSITION   ] = "LABTABLE_INPUT"

	special_actions_report [ 3 , CHARACTER_POSITION ] = "2"
	special_actions_report [ 3 , TITLE_POSITION     ] = "2 Analysis Description"
	special_actions_report [ 3 , LIBRARY_POSITION   ] = "$LABTABLIB"
	special_actions_report [ 3 , ROUTINE_POSITION   ] = "TEXT_FILE"

}

	ARRAY 	special_actions_report 	ARRAY_SIZE ( 0 , 4 )

{

	move the comments braces to allow use of these statements

}

{

	special_actions_report [ 1 , CHARACTER_POSITION ] = "1"
	special_actions_report [ 1 , TITLE_POSITION     ] = "1 Phrase List"
	special_actions_report [ 1 , LIBRARY_POSITION   ] = "$PHRASE"
	special_actions_report [ 1 , ROUTINE_POSITION   ] = "DO_PHRASE_LIST"

}


{

	CHANGE : OPTIONAL : Specify five standard messages.

                IDENTITY1_MESSAGE contains title text for the identity field.
                MOD_ON_MESSAGE    contains title text for the Modified On field.
                MOD_BY_MESSAGE    contains title text for the Modified by field.
                READ_MESSAGE      contains identifier for the read transaction.
                WRITE_MESSAGE     contains identifier for the write transaction

		Note:
		Where a table contains more than one key0 field, then messages
		for the second (and third and fourth, if appropriate) key0
		fields should be set up in the IDENTITY2_MESSAGE,
		IDENTITY3_MESSAGE and IDENTITY3_MESSAGE elements.

}

        ARRAY 	labtable_messages 	ARRAY_SIZE ( 0 )


        labtable_messages [ IDENTITY1_MESSAGE ] = GET_USER_MESSAGE ( "INST_CALIB_LTE_ID" , 1 )
        labtable_messages [ IDENTITY2_MESSAGE ] = GET_USER_MESSAGE ( "INST_CALIB_LTE_TYPE" , 1 )
        labtable_messages [ IDENTITY3_MESSAGE ] = GET_USER_MESSAGE ( "INST_CALIB_LTE_SEQUENCE" , 1 )
        labtable_messages [ IDENTITY4_MESSAGE ] = GET MESSAGE ( 2884 , 3 )  { "Identity 4" }
        labtable_messages [ MOD_ON_MESSAGE    ] = GET_USER_MESSAGE ( "INST_CALIB_LTE_MOD_ON" , 1 )
        labtable_messages [ MOD_BY_MESSAGE    ] = GET_USER_MESSAGE ( "INST_CALIB_LTE_MOD_BY" , 1 )
        labtable_messages [ READ_MESSAGE      ] = GET_USER_MESSAGE ( "INST_CALIB_LTE_LTE_READ_TRANS" , 1 )
        labtable_messages [ WRITE_MESSAGE     ] = GET_USER_MESSAGE ( "INST_CALIB_LTE_LTE_WRITE_TRANS" , 1 )


{

	CHANGE : MANDATORY : Specify the help context for the editor window.
		 The text should be specified literally and should start
		 with the name of the report, suffixed with "_EDIT",
		 	i.e. "$LTE_XXX_EDIT"

}

	help_context = "$LTE_TEM_EDIT"




 {   ------	THERE ARE NO MORE FIELDS TO BE SETUP  --------    }

ENDROUTINE





{ --------------------------------------------------------------------------- }
{                                                                             }
{ The following routines are provided as call back points for LTE processing. }
{ User code may be added as appropriate.                                      }
{ --------------------------------------------------------------------------- }

ROUTINE update_routine ( labtable )

	{ Called on pressing the DO key to save LTE screen.               }
	{ Called after the LTE write transaction has been started.        }
	{                                                                 }
	{ labtable is the labtable object.                                }
	{                                                                 }
	{ The return value is TRUE  if updates have been performed        }
	{                     FALSE if updates have NOT been performed    }
	{                     EMPTY - the systems checks for updates      }

    { 1.4 some of this was in do_initialise, but this not called from MODIFY }
    DECLARE date_next_cal, date_calibrated, cal_interval , ty, in

    IF (STRIP(TOUPPER(operation)) = "MODIFY_IDENT") THEN

       date_calibrated = SELECT inst_calib_hist.date_calibrated 
       in = SELECT inst_calib_hist.instrument
       ty = SELECT inst_calib_hist.type

       cal_interval = SELECT inst_calibration.interval
                               WHERE   ( instrument = in)
                               AND ( type = ty)


        IF ( cal_interval <> EMPTY )  AND (date_calibrated <> "")  THEN

            date_next_cal = date_calibrated + cal_interval
            ASSIGN inst_calib_hist.calculated_calib_due = date_next_cal

        ENDIF

 ENDIF


        RETURN ( EMPTY )
    { end 1.4 }

ENDROUTINE


ROUTINE read_data_routine (       labtable  ,
                            VALUE operation )

	{ Called after the record has been selected / reserved but before }
	{ the editor screen has been built.                               }
        {                                                                 }
	{ labtable      the labtable object.                              }
	{ operation     the current LTE operation eg ADD, MODIFY, DISPLAY }
        {                                                                 }
	{ No return value is required                                     }

{ 1.4 }
    operation = STRIP(TOUPPER(operation))

    IF (operation="ADD") OR
        (operation="COPY") THEN

      do_initialise ()   

    ENDIF

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE validate_new_id_routine ( VALUE new_id )

	{ Called after each ID value has been entered.                    }
	{                                                                 }
	{ new_id is the value entered at the prompt.                      }
	{                                                                 }
	{ Returns a boolean value to indicate whether the value is valid. }

	RETURN ( TRUE )

ENDROUTINE

ROUTINE validation_routine

    { 
       Called on pressing the DO key to save LTE screen.               
       Called outside of the LTE write transaction.                    

       Returns a boolean value to indicate whether to proceed with     
       the save process - if FALSE is returned the user is forced back 
       into the editor
    }


    DECLARE date_calibrated, cal_interval, date_next_cal, actual_calib_due
    DECLARE form


    labtablib_get_form ( form )


    {  Check date format  }
    date_calibrated = SELECT inst_calib_hist.date_calibrated

    IF (date_calibrated = "" )

        flash_message (GET_USER_MESSAGE ( "INST_CALIB_HIST_NO_DATE_ENTERED" , 1 ), TRUE)
        RETURN (FALSE)

    ENDIF


    {   Check that a calibration interval has been defined for the selected instrument & calibration type   }

    cal_interval = SELECT inst_calibration.interval
                               WHERE   ( instrument = form . prompt_objects[1] . value)
                               AND ( type = form . prompt_objects[2] . value)


    IF ( cal_interval = EMPTY )    

        RETURN (FALSE)

    ENDIF



    actual_calib_due = SELECT inst_calib_hist.actual_calib_due

    {  Check that date is in the future  }
{EH Modified to remove modification if date is in the future 08-JUN-2004 }
{  
    cal_interval = actual_calib_due - NOW

    IF ( INTERVAL(cal_interval) < INTERVAL(0))

        flash_message (GET_USER_MESSAGE ( "INST_CALIB_HIST_WRONG_DATE_DUE1" , 1 ), TRUE)
        RETURN (FALSE)

    ENDIF}
{EH end of modification 08-JUN-2004}


    IF (is_new_entry = TRUE)
 
        { 
             If get here, will print a label, set a flag because it has to be done later,
             when all the data is committed
        }
        g_print_label = TRUE
             
    ENDIF


    RETURN (  TRUE  )


ENDROUTINE


{ --------------------------------------------------------------------------- }

ROUTINE prompt_object_routine (       prompt_object ,
                                VALUE key0_count    ,
                                VALUE operation     )

    {
        Called during the creation of the identity prompts         
        prompt_object is the prompt object for the specified prompt     
        key0_count    is the current key0 segment number                
        eg this would be 2 for the version_number         
        field of the versioned_analysis table          
        operation     the current LTE operation eg ADD, MODIFY, DISPLAY 

        No return value is required                                     
    }


 
    {
        The code below makes the identity prompts read-only on the calibration
        record data entry screen (instrument is entered on another form, type is got from
        the menu procedure number and sequence number is got from the database
    }

    IF ( operation = "ADD" )
       OR ( operation = "NEW_VERSION" )
    
        prompt_object . display_only = TRUE
        
    ENDIF
    
ENDROUTINE

{ --------------------------------------------------------------------------- }


ROUTINE ident_prompt_object_routine (       prompt_object ,
				      VALUE ident_field   )

	{ Called from the ident form for for each identity prompt when    }
	{ copying, printing etc.                                          }
        {                                                                 }
	{ prompt_object is the prompt object for the specified prompt     }
	{ ident_field   is the name of the identity field to prompt for   }
	{               eg ANALYSIS_VERSION                               }
	{                  version field of the versioned_analysis table  }
        {                                                                 }
	{ No return value is required                                     }

DECLARE operation , labtable

	labtablib_get_labtable ( labtable )

	operation = labtable . operation

ENDROUTINE

{ --------------------------------------------------------------------------- }




{******************************************************************************
*                                                                              
*  Routine Name     :  add_cal_record
*                                                                             
* Description:  Called from the menu. The menu procedure number is passed 
*                           as the 'option' parameter. Based on this procedure number, the type of 
*                           calibration can be retrieved from the 'inst_calib_types' table, and the
*                           appropriate parameter can be passed to routine 'add_calibration'
*                                                                                                                                                            
* Parameters       :  
*             option - menu procedure number
*                                                                              
* Return Value     :  none
*                                                                                                                                                            
*******************************************************************************}
ROUTINE add_cal_record ( option )

    DECLARE cal_type, title_cal_type

    cal_type = SELECT inst_calib_types.identity
                           WHERE   ( procedure_num = option )

    IF ( cal_type = EMPTY )    

        flash_message (GET_USER_MESSAGE ( "INST_CALIB_HIST_TYPE_MENU_ERR" , 1 ), TRUE)

    ELSE

        { want calibration type in title to have 1st letter uppercase & the rest lowercase}
        title_cal_type = leftstring (toupper(cal_type),1):rightstring (tolower(cal_type),length(cal_type)-1)

        add_calibration( cal_type, "Record ":title_cal_type:" Calibration" )

    ENDIF


    RETURN
    
ENDROUTINE     {  add_cal_record  }




{******************************************************************************
*                                                                              
*  Routine Name     :  add_calibration
*                                                                             
* Description      :  Called from menu to add calibration record. 
*                     Parameters passed are calibration type and screen title.
*                                                                                                                                                            
* Parameters       :  
*      VALUE  type - the calibration type
*      VALUE   title  - the GUI title
*                                                                              
* Return Value     :  none
*                                                                                                                                                            
*******************************************************************************}
ROUTINE add_calibration
    (
    VALUE   type,
    VALUE   title
    )

    DECLARE form
    DECLARE labtable_mode
    DECLARE last_version
    DECLARE cal_interval
    DECLARE cal_int_ok
    


    setup_instrument_form( form, title )

    form . start_prompt()

    
    REPEAT
    
        form . wait_prompt()


        {
             If there is no calibration interval defined, dont go any further
        }        
        cal_int_ok = TRUE
        cal_interval = SELECT inst_calibration.interval
                                   WHERE   ( instrument = form . prompt_objects[1] . value)
                                   AND ( type = type)



        IF ( cal_interval = EMPTY )  
              AND ( form . get_lastkey() <> "EXIT" )  
        
            cal_int_ok = FALSE
            flash_message(GET_USER_MESSAGE ( "INST_CALIB_HIST_NO_INT_SET" , 1 ), TRUE)

        ENDIF



        IF ( form . get_lastkey() = "DO" )
            AND ( cal_int_ok = TRUE )


            last_version = SELECT MAX inst_calib_hist.calibration_number
                                        WHERE ( instrument = form . prompt_objects[1] . value )
                                        AND   ( type = type )


           {    labtable_mode set temporarily to TRUE regardless of its configured value    }

            labtable_mode = GLOBAL( "labtable_mode" )
            SET GLOBAL "labtable_mode" TO TRUE



           {   MENUPROC 56 calls routine do_the_work   }

            IF ( last_version = EMPTY )

                MENUPROC 56 USING GLOBAL( "current_library" ),
                                  "ADD",
                                  form . prompt_objects[1] . value,
                                  type,
                                  "1"



            ELSE

                last_version = last_version + 1
                SET FORMAT "9999999999" 
                last_version = STRIP( last_version )
                
                MENUPROC 56 USING GLOBAL( "current_library" ),
                                  "ADD",   {"NEW_VERSION",}
                                  form . prompt_objects[1] . value,
                                  type,
                                  last_version
                                                                                
            ENDIF
            

            SET GLOBAL "labtable_mode" TO labtable_mode

        ENDIF
        
    UNTIL ( form . get_lastkey() = "EXIT" )
    OR    ( GLOBAL( "labtable_mode" ) = FALSE )
    OR     ( cal_int_ok = FALSE )
    
    form . end_prompt()
    
    RETURN

    
ENDROUTINE   {  add_calibration  }





{******************************************************************************
*                                                                              
*  Routine Name     :  do_the_work
*                                                                             
* Description: 
*                                                                                                                                                            
* Parameters       :  
*     VALUE operation
*                                                                              
* Return Value     :  none
*                                                                                                                                                            
*******************************************************************************}
ROUTINE do_the_work  ( VALUE operation )

    DECLARE status, inst, type, cal_num

    { initialise global variables }
    is_init = FALSE
    is_new_entry = FALSE
    g_print_label = FALSE

    table_setup ()


    SET DATE FORMAT "DD-MON-YYYY H24:MI:SS"


    smp_lte_perform_option  ( name_of_table ,
	    	              displayed_name_of_table ,
	    	              prompt_details ,
	    	              labtable_messages ,
	    	              default_value ,
	    	              input_mess ,
		              header_mess  ,
		              footer_mess ,
	    	              display_footer_mess ,
	    	              directory ,
	    	              extn ,
	    	              help_context  ,
		              GLOBAL ("CURRENT_LIBRARY") ,
	    	              fields_to_output ,
	    	              special_actions_report ,
	    	              operation                   )


    RESTORE DATE FORMAT



    { 
        Print calibration label here (if necessary )  
        This is done here because it has to be done after the data is committed
         Infomaker report retrieves data from the database
       }

    IF ( g_print_label = TRUE)

        labtablib_get_form ( form )

        inst = form.prompt_objects[1].value
        type = form.prompt_objects[2].value
        cal_num = form.prompt_objects[3].value

        status = SELECT inst_calib_hist.status 
                       WHERE (instrument = inst)
                       AND (type = type)
                       AND (calibration_number = cal_num)

        cal_label_print ( inst, type, cal_num, status )

    ENDIF

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE add_option ( option )

    do_the_work ( "add_ident" )

ENDROUTINE


{ --------------------------------------------------------------------------- }

ROUTINE new_version_option ( option )

    do_the_work ( "new_version" )

ENDROUTINE


{ --------------------------------------------------------------------------- }

ROUTINE copy_option ( option )

    do_the_work ( "copy_ident" )
 
ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE modify_option ( option )

    do_the_work ( "modify_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE display_option ( option )

    do_the_work ( "display_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE remove_option ( option )

    do_the_work ( "remove_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE restore_option ( option )

    do_the_work ( "restore_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE list_option ( option )

    do_the_work ( "list_idents" )

ENDROUTINE

{ --------------------------------------------------------------------------- }

ROUTINE print_option ( option )

    do_the_work ( "print_ident" )

ENDROUTINE

{ --------------------------------------------------------------------------- }




{******************************************************************************
*                                                                              
*  Routine Name     :  smp_lte_initialise
*                                                                             
* Description:  This routine sets default values to be displayed when the screen
              is first displayed
*                                                                                                                                                            
* Parameters       :  none
*                                                                              
* Return Value     :  none
*                                                                                                                                                            
*******************************************************************************}
ROUTINE smp_lte_initialise

   { 1.4 modification - move functionality }


ENDROUTINE    {  smp_lte_initialise  }


{ 1.4 }
ROUTINE do_initialise

    DECLARE date_calibrated, form, cal_interval, date_next_cal
    DECLARE location, group

    date_calibrated = NOW

    ASSIGN inst_calib_hist.status = TRUE
    ASSIGN inst_calib_hist.comments = ""
    ASSIGN inst_calib_hist.external_by= ""
    ASSIGN inst_calib_hist.date_calibrated = date_calibrated

    {  INTERVAL("0 00:00:01") added so that no errors over date not being in the future until Date Calibrated is set  }
    ASSIGN inst_calib_hist.actual_calib_due = date_calibrated + INTERVAL("0 00:00:01")

    labtablib_get_form ( form )

    cal_interval = SELECT inst_calibration.interval
                               WHERE   ( instrument = form . prompt_objects[1] . value)
                               AND ( type = form . prompt_objects[2] . value)


    IF ( cal_interval <> EMPTY )    

        date_next_cal = date_calibrated + cal_interval
        ASSIGN inst_calib_hist.calculated_calib_due = date_next_cal
        ASSIGN inst_calib_hist.actual_calib_due = date_next_cal

    ELSE

        flash_message(GET_USER_MESSAGE ( "INST_CALIB_HIST_NO_INT_SET" , 1 ), TRUE)

    ENDIF



   {  Set default instrument location and group  }

    location = SELECT instrument.location_id
         WHERE   ( identity = form . prompt_objects[1] . value)

    IF (location <> EMPTY)

        ASSIGN inst_calib_hist.location = location

    ENDIF


    group = SELECT instrument.group_id


    IF (group <> EMPTY)

        ASSIGN inst_calib_hist.group_id = group

    ENDIF


ENDROUTINE    {  do_initialise  }








{******************************************************************************
*                                                                              
*  Routine Name     :  setup_instrument_form
*                                                                             
* Description      :  Initialises main LTE form
*                                                                                                                                                            
* Parameters       :  
*      form  - the form
*      VALUE   title  - the GUI title
*                                                                              
* Return Value     :  none
*                                                                                                                                                            
*******************************************************************************}
ROUTINE setup_instrument_form
    (
            form,
    VALUE   title            
    )
    
    DECLARE title
    DECLARE prompt_object
    
    title = SELECT master_menu.description
            WHERE  procedure_num = option

    CREATE OBJECT "std_form", form
    
    form . row    = 1
    form . column = 10
    form . height = 1
    form . width  = 40
    form . header = title
    form . return_behaviour = FORM_RETURN_LEAVE
    
    PROMPT OBJECT prompt_object
            BROWSE ON   instrument
            ON LINE     1
            FROM        23
            WITH        (
                        always_validate = TRUE
                        )
                        
    form . add_prompt( prompt_object )
    form . add_display( PAD( "Instrument", " ", 20 ), 2, 1, PROMPT_RENDITION_LOWERED )

    
ENDROUTINE    {  setup_instrument_form  }







{******************************************************************************
*                                                                              
*  Routine Name     :  prompt_date_calibrated
*                                                                             
* Description      :  Passed as ROUTINE_POSITION for 'date calibrated' field.
*                                Updates the value in the 'calibration due(actual)' and
*                                'calibration due(calculated)' fields.
*                                Only called when adding new record.
*                                                                                                                                                            
* Parameters       :  
*         VALUE column
*         VALUE row
*         VALUE cell_width
*          window
*          VALUE is_display 
*                                                                              
* Return Value     :  none
*                                                                                                                                                            
*******************************************************************************}
ROUTINE prompt_date_calibrated ( VALUE column     ,
                                 VALUE row        ,
                                 VALUE cell_width ,
                                   window     ,
                                 VALUE is_display )


    DECLARE date_calibrated, form, labtable
      

    {  initialise the display (only the first time this routine is entered) }
     IF is_init = FALSE

        is_init = TRUE
        smp_lte_initialise ()

    ENDIF



    labtablib_get_form ( form )


    date_calibrated = SELECT inst_calib_hist.date_calibrated


    IF is_display THEN

        DISPLAY date_calibrated
                ON LINE   row
                FROM 	  column
                TO        column + cell_width - 1
                IN WINDOW window

    ELSE

        PROMPT  FOR  date_calibrated
                ON LINE   row
                FROM 	  column
                TO        column + cell_width - 1
                IN WINDOW window
                FORMAT inst_calib_hist.date_calibrated

    ENDIF

 
    ASSIGN inst_calib_hist.date_calibrated = date_calibrated


    IF (date_calibrated = "" )

        flash_message (GET_USER_MESSAGE ( "INST_CALIB_HIST_NO_DATE_ENTERED" , 1 ), TRUE)
        RETURN

    ENDIF


    {
        calculated_calib_due and actual_calib_due will now be updated with time =
        date_calibrated + interval from instrument_calibration table

        If no interval defined, this will be caught in validation_routine (called on clicking OK)
    }

    cal_interval = SELECT inst_calibration.interval
                               WHERE   ( instrument = form . prompt_objects[1] . value)
                               AND ( type = form . prompt_objects[2] . value)


    IF ( cal_interval <> EMPTY )    

        date_next_cal = date_calibrated + cal_interval
        ASSIGN inst_calib_hist.calculated_calib_due = date_next_cal
        ASSIGN inst_calib_hist.actual_calib_due = date_next_cal  

    ENDIF

     
ENDROUTINE  { prompt_date_calibrated }







{******************************************************************************
*                                                                              
*  Routine Name     :  prompt_actual_calib_due
*                                                                             
* Description      :  Passed as ROUTINE_POSITION for 'next calibrated due(actual)' field.
*                                Checks that the field value is in the future. 
*                                Only called when adding new record.
*                                                                                                                                                            
* Parameters       :  
*         VALUE column - 
*         VALUE row
*         VALUE cell_width
*          window
*          VALUE is_display 
*                                                                              
* Return Value     :  none
*                                                                                                                                                            
*******************************************************************************}
ROUTINE prompt_actual_calib_due ( VALUE column     ,
                                  VALUE row        ,
                                  VALUE cell_width ,
                                   window     ,
                                  VALUE is_display )


    DECLARE actual_calib_due, cal_interval

           
    actual_calib_due = SELECT inst_calib_hist.actual_calib_due


    IF is_display THEN

        DISPLAY actual_calib_due
                ON LINE   row
                FROM 	  column
                TO        column + cell_width - 1
                IN WINDOW window

    ELSE

        PROMPT  FOR  actual_calib_due
                ON LINE   row
                FROM 	  column
                TO        column + cell_width - 1
                IN WINDOW window
                FORMAT inst_calib_hist.actual_calib_due

    ENDIF
 
    ASSIGN inst_calib_hist.actual_calib_due = actual_calib_due

    {  Check that date is in the future  }
    cal_interval = actual_calib_due - NOW

    IF ( INTERVAL(cal_interval) < INTERVAL(0))

        flash_message (GET_USER_MESSAGE ( "INST_CALIB_HIST_WRONG_DATE_DUE1" , 1 ), TRUE)

    ENDIF



ENDROUTINE   { prompt_actual_calib_due  }






{******************************************************************************
*                                                                              
*  Routine Name     :  cal_label_print
*                                                                             
* Description      :  Displays 'print calibration screen'. 
*                                Called on clicking OK on calibration record data entry screen
*                                                                                                                                                            
* Parameters       :  
*         instrument - the instrument identity
*         type - the calibration type
*        cal_num - the calibration sequence number
*        status - the calibrtion result. Pass=TRUE, Fail=FALSE
*                                                                              
* Return Value     :  none
*                                                                                                                                                            
*******************************************************************************}
ROUTINE cal_label_print  ( instrument, type, cal_num, status )
    
    DECLARE title, labtable_mode

    CREATE OBJECT "std_form", form
    
    form . row    = 1
    form . column = 10
    form . height = 1
    form . width  = 30
    form . header = "Instrument Calibration Label"
    form . return_behaviour = FORM_RETURN_LEAVE
    
    form . add_display( PAD( "Print Calibration Label ?", " ", 25 ), 7, 1, PROMPT_RENDITION_BOLD )


    form . start_prompt()
    form . wait_prompt()

    IF ( form . get_lastkey() = "DO" )
       
        IF (status = TRUE)

            imprint_print_cal_label ( instrument, type, cal_num )

        ELSE

            vgl_print_dont_use_label ( instrument, type, cal_num )

        ENDIF

    ENDIF

    form . end_prompt()


    RETURN

    
ENDROUTINE   {  cal_label_print    }




{******************************************************************************
*                                                                              
* Routine Name     : vgl_print_dont_use_label
*                                                                             
* Description      :  Calls a report in INST_CALIB_BGR_REP to print the
*                     'DO NOT USE' label. That report depends on the calibration type
*                     (Database entry associated with each calibration type - the report name)                                                        
*
* Parameters       :  
*         VALUE inst - the instrument
*         VALUE type - the calibration type
*         VALUE cal_no - the calibration sequence number
*                                                                              
* Return Value     :  TRUE if value entered is valid, else FALSE
*                                                                                                                                                            
*******************************************************************************}
ROUTINE vgl_print_dont_use_label ( VALUE inst, VALUE type, VALUE cal_no)

    DECLARE report


    {    the report name is in database    }
    report = SELECT inst_calib_types.dnu_label
                    WHERE (identity = type)
      

    IF ( report = EMPTY)

        flash_message ("No 'Do Not Use' label report name set for this calibration type", TRUE)
        
    ELSE

        CALL_ROUTINE report USING inst, type, cal_no
                 IN LIBRARY "inst_calib_rep_bgr"

    ENDIF



ENDROUTINE




