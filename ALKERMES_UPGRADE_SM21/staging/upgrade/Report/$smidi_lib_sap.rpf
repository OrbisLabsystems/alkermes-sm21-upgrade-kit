{******************************************************************************
*
* Module Name   : $SMIDI_LIB_SAP
*
* Purpose       : Support for SM-IDI core library used by most SM-IDI
*
* Document Ref. :
*
* Specification :
*
* Portability   : NT, Windows2000, VMS, UNIX
*
* Re-entrant    :
*
* Modification History
*      By        Date        Reason _____________________________________________
*
*******************************************************************************}

ENABLE WINDOWS

SET NAME "DISPLAY/"
SET NOTPROTECTED
SET COMPILE_OPTION DECLARE
SET COMPILE_OPTION EXP_MESS

JOIN STANDARD_LIBRARY STD_ARRAY         { Array selection for SSE's            }
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT  { array_x_slice                        }
JOIN STANDARD_LIBRARY STD_BLOCK         { block_row for the SSE's from LTE's   }
JOIN STANDARD_LIBRARY STD_CLASS         { object invoke class / check property }
JOIN STANDARD_LIBRARY STD_CLIENT        { client_registry_get_value            }
JOIN STANDARD_LIBRARY STD_DATABASE      { transaction_is_write                 }
JOIN STANDARD_LIBRARY STD_GENERAL       { variable_get_type, objects           }
JOIN STANDARD_LIBRARY STD_FLAGS         {                                      }
JOIN STANDARD_LIBRARY STD_MESSAGE       { message fetch get text add param     }
JOIN STANDARD_LIBRARY STD_SMIDI         { SMIDI Constants                      }
JOIN STANDARD_LIBRARY STD_UTILS         { size of array variable is assigned   }
JOIN STANDARD_LIBRARY STD_VGL           {                                      }
JOIN STANDARD_LIBRARY STD_VGL_TOOLS     { vgl_tools_class_redefinable          }
JOIN STANDARD_LIBRARY STD_WINDOW        { window_set_status                    }

JOIN LIBRARY $SAMP_JOB                  { samp_job_initialise                  }
JOIN LIBRARY $TEST_ASSN                 { testassigninitialise                 }
JOIN LIBRARY $SSE_LIB                   { Spreadsheets for all the LTE's       }
JOIN LIBRARY $LIB_UTILS                 { flash_message                        }

{* LOCAL CONSTANTS ************************************************************}

	CONSTANT MAX_WIDTH                               = 10
	CONSTANT idi_cat_type_length                     = 41

{* GLOBAL CONSTANTS ***********************************************************}

{ Class names }

	GLOBAL CONSTANT SMIDI_BASE_CLASS                 = "SMIDI_V2"
	GLOBAL CONSTANT SMIDI_QIRF_CLASS                 = "SMIDI_QIRF"
	GLOBAL CONSTANT SMIDI_DOWNLOAD_CLASS             = "SMIDI_DOWNLOAD"
	GLOBAL CONSTANT SMIDI_CLUSTER_NAME               = "SMIDI_SAP_OBJECTS"
	GLOBAL CONSTANT SMIDI_CNF_COLLECTION_CLASS       = "SMIDICNFCOLLECTION"
	GLOBAL CONSTANT SMIDI_CNF_COLLECTED_CLASS        = "SMIDICNFCOLLECTED"
	GLOBAL CONSTANT SMIDI_QUEUE_CLASS                = "SMIDI_QUE2"
	GLOBAL CONSTANT SMIDI_QUEUE_ITEM_CLASS           = "SMIDI_UP_2"

{ Base library names }  

	GLOBAL CONSTANT SMIDI_LIB_ALT                    = "$SMIDI_LIB_ALT"
	GLOBAL CONSTANT SMIDI_LIB_QPUP                   = "$SMIDI_LIB_QPUP"
	GLOBAL CONSTANT SMIDI_LIB_SAP                    = "$SMIDI_LIB_SAP"
	GLOBAL CONSTANT SMIDI_LIB_CLEAN                  = "$SMIDI_LIB_CLEAN"
	GLOBAL CONSTANT SMIDI_LIB_LOGIN                  = "$SMIDI_LIB_LOGIN"
	GLOBAL CONSTANT SMIDI_LIB_LIMITS                 = "$SMIDI_LIB_LIMITS"
	GLOBAL CONSTANT SMIDI_LIB_PHRASE                 = "$SMIDI_LIB_PHRASE"
	GLOBAL CONSTANT SMIDI_LIB_UPLOAD_LIB             = "$SMIDI_LIB_UPLOAD"
	GLOBAL CONSTANT SMIDI_LTE_SYSTEM                 = "$SMIDI_LTE_SYSTEM"

{ User library names.views }

	GLOBAL CONSTANT SMIDI_USER_LIB                   = "$SMIDI_USER"
	GLOBAL CONSTANT SMIDI_DEFECT_USER_LIB            = "$SMIDI_USER"
	GLOBAL CONSTANT SMIDI_GET_LOT_USER_LIB           = "$SMIDI_USER"
	GLOBAL CONSTANT SMIDI_POINT_USER_LIB             = "$SMIDI_USER"
	GLOBAL CONSTANT SMIDI_PROCESS_USER_LIB           = "$SMIDI_USER"
	GLOBAL CONSTANT SMIDI_UPLOAD_USER_LIB            = "$SMIDI_USER"

	GLOBAL CONSTANT SMIDI_GET_LOTS                   = "SMIDI_QUERY_VIEW"
	GLOBAL CONSTANT SMIDI_GET_POINTS                 = "SMIDI_POINTS_VIEW"

	GLOBAL CONSTANT SMIDI_PROCESS_LOT                = "SMIDI_PROCESS_VIEW"
	GLOBAL CONSTANT SMIDI_PROCESS_POINT              = "SMIDI_PROCESS_POINT_VIEW"

	GLOBAL CONSTANT POINTS_PROCESS_ROUTINE           = "process_download_queue"

{ Key object definitions that drive all SAP objects/background }

	GLOBAL CONSTANT SMIDI_QMIDI_OBJECT_LIST          = "#1#2#"     { add new SAP numbers to here          }
	GLOBAL CONSTANT DEFAULT_QMIDI_OBJECT             = 1           { <- better be the only placed defined }
	GLOBAL CONSTANT DEFAULT_QMIDI_VERSION            = "46c"       { not used but information anyway      }
	GLOBAL CONSTANT DEFAULT_SMIDI_SERVER             = "DEFAULT"
	GLOBAL CONSTANT DEFAULT_SMIDI_QUERY              = "DEFAULT"
	GLOBAL CONSTANT DEFAULT_MAPPING_PROFILE          = "DEFAULT"
	GLOBAL CONSTANT LOT_TEMPLATE                     = "BLANK"     { Default template for lot login       }

	GLOBAL CONSTANT HKEY_SAMPLE_MANAGER_SERVICES     = "Software\LabSystems\SampleManager Server"
	GLOBAL CONSTANT SMIDI_SERVICE_PREFIX             = "smpback"

	GLOBAL CONSTANT INSP_STATUS_STORES_CHARS         = "#A#B#"     { inspection statuses that store chars }

{ Error Messages }

	GLOBAL CONSTANT MSG_NONE                         = 0
	GLOBAL CONSTANT MSG_LOW                          = 1
	GLOBAL CONSTANT MSG_MED                          = 5
	GLOBAL CONSTANT MSG_HIGH                         = 10
	GLOBAL CONSTANT MSG_FULL                         = 11

	GLOBAL CONSTANT MSG_0                            = 0
	GLOBAL CONSTANT MSG_1                            = 1
	GLOBAL CONSTANT MSG_2                            = 2
	GLOBAL CONSTANT MSG_3                            = 3
	GLOBAL CONSTANT MSG_4                            = 4
	GLOBAL CONSTANT MSG_5                            = 5
	GLOBAL CONSTANT MSG_6                            = 6
	GLOBAL CONSTANT MSG_7                            = 7
	GLOBAL CONSTANT MSG_8                            = 8
	GLOBAL CONSTANT MSG_9                            = 9
	GLOBAL CONSTANT MSG_10                           = 10

{ Interface to error messages in message.txt }

	GLOBAL CONSTANT SMIDI_BADSYS                     = 100
	GLOBAL CONSTANT SMIDI_BADMSG                     = 101
	GLOBAL CONSTANT SMIDI_NOLIB                      = 102
	GLOBAL CONSTANT SMIDI_BADPHRASE                  = 103
	GLOBAL CONSTANT SMIDI_PHRASELOCK                 = 104
	GLOBAL CONSTANT SMIDI_ABORTED                    = 105
	GLOBAL CONSTANT SMIDI_JOBFAIL                    = 106
	GLOBAL CONSTANT SMIDI_SAMPFAIL                   = 107
	GLOBAL CONSTANT SMIDI_OPFAIL                     = 108
	GLOBAL CONSTANT SMIDI_CHARFAIL                   = 109
	GLOBAL CONSTANT SMIDI_BADANAL                    = 110
	GLOBAL CONSTANT SMIDI_CETFAIL                    = 111
	GLOBAL CONSTANT SMIDI_BADMLP                     = 112
	GLOBAL CONSTANT SMIDI_ILLPHRASE                  = 113
	GLOBAL CONSTANT SMIDI_BADTEST                    = 114
	GLOBAL CONSTANT SMIDI_RESLOCK                    = 115
	GLOBAL CONSTANT SMIDI_NOREQ                      = 116
	GLOBAL CONSTANT SMIDI_RESTYPE                    = 117
	GLOBAL CONSTANT SMIDI_BADTNUM                    = 118
	GLOBAL CONSTANT SMIDI_MLPCRE                     = 119
	GLOBAL CONSTANT SMIDI_MLPVER                     = 120
	GLOBAL CONSTANT SMIDI_BADCOMP                    = 121
	GLOBAL CONSTANT SMIDI_NOQUERY                    = 122
	GLOBAL CONSTANT SMIDI_BADFILTER                  = 123
	GLOBAL CONSTANT SMIDI_EMPTYWL                    = 124
	GLOBAL CONSTANT SMIDI_BADPROC                    = 125
	GLOBAL CONSTANT SMIDI_DNLCOMMIT                  = 126
	GLOBAL CONSTANT SMIDI_JOBNOTIDI                  = 127
	GLOBAL CONSTANT SMIDI_JOBNOREQ                   = 128
	GLOBAL CONSTANT SMIDI_JOBNOUD                    = 129
	GLOBAL CONSTANT SMIDI_NOPHRASE                   = 130
	GLOBAL CONSTANT SMIDI_BADVERS                    = 131
	GLOBAL CONSTANT SMIDI_FAILPHRASE                 = 132
	GLOBAL CONSTANT SMIDI_BADLIST                    = 133
	
{ Triggers }

	GLOBAL CONSTANT GBI_MAPPING_TRIGGER_TRIGGER      = 1
	GLOBAL CONSTANT GBI_NEW_MLP_TRIGGER              = 2
	GLOBAL CONSTANT GBI_ASSIGN_LEVEL_TRIGGER         = 3
	GLOBAL CONSTANT GBI_NEW_VERSION_TRIGGER          = 4
	GLOBAL CONSTANT GBI_CHECK_COMPONENT_TRIGGER      = 5
	GLOBAL CONSTANT GBI_NEW_COMPONENT_TRIGGER        = 6
	GLOBAL CONSTANT GBI_VERIFY_LIMITS_TRIGGER        = 7
	GLOBAL CONSTANT GBI_ASSIGN_LEVELS_TRIGGER        = 8
	GLOBAL CONSTANT GBI_UPDATE_LIMITS_TRIGGER        = 9
	GLOBAL CONSTANT GBI_COPY_SCHEDULE_TRIGGER        = 10
	GLOBAL CONSTANT GBI_NEW_LIMIT_TRIGGER            = 11
	GLOBAL CONSTANT GBI_COPY_LIMIT_TRIGGER           = 12
	GLOBAL CONSTANT GBI_DO_COPY_LIMIT_TRIGGER        = 13
	GLOBAL CONSTANT GBI_DO_COPY_SCHED_TRIGGER        = 14
	GLOBAL CONSTANT GBI_DO_COPY_COMPONENT_TRIGGER    = 15
	GLOBAL CONSTANT GBI_COPY_COMPONENT_TRIGGER       = 16
	GLOBAL CONSTANT GBI_NEW_LEVEL_TRIGGER            = 17
	GLOBAL CONSTANT GBI_CHECK_MLP_TRIGGER            = 18
	GLOBAL CONSTANT GBI_CHECK_MLP_VERSION_TRIGGER    = 19

	GLOBAL CONSTANT SML_NEW_MLP_TRIGGER              = 20
	GLOBAL CONSTANT SML_ASSIGN_LEVEL_TRIGGER         = 21
	GLOBAL CONSTANT SML_NEW_VERSION_TRIGGER          = 22
	GLOBAL CONSTANT SML_CHECK_COMPONENT_TRIGGER      = 23
	GLOBAL CONSTANT SML_NEW_COMPONENT_TRIGGER        = 24
	GLOBAL CONSTANT SML_VERIFY_LIMITS_TRIGGER        = 25
	GLOBAL CONSTANT SML_ASSIGN_LEVELS_TRIGGER        = 26
	GLOBAL CONSTANT SML_UPDATE_LIMITS_TRIGGER        = 27
	GLOBAL CONSTANT SML_COPY_SCHEDULE_TRIGGER        = 28
	GLOBAL CONSTANT SML_NEW_LIMIT_TRIGGER            = 29
	GLOBAL CONSTANT SML_COPY_LIMIT_TRIGGER           = 30
	GLOBAL CONSTANT SML_DO_COPY_LIMIT_TRIGGER        = 31
	GLOBAL CONSTANT SML_DO_COPY_SCHED_TRIGGER        = 32

	GLOBAL CONSTANT SML_FAILURE_FILTER_TRIGGER       = 33
	GLOBAL CONSTANT SML_ADD_FAILURE_TRIGGER          = 34
	GLOBAL CONSTANT SML_ALL_FAILURE_TRIGGER          = 35

	GLOBAL CONSTANT SML_DOWNLOAD_LOOP_TRIGGER        = 36
	GLOBAL CONSTANT SML_DOWNLOAD_ERROR_TRIGGER       = 37
	GLOBAL CONSTANT SML_DOWNLOAD_COMMIT_TRIGGER      = 38
	GLOBAL CONSTANT SML_DOWNLOAD_POST_COMMIT_TRIGGER = 39

	GLOBAL CONSTANT SML_ADD_VGL_FAILURE_TRIGGER      = 40
	GLOBAL CONSTANT SML_CREATE_FAILURE_TRIGGER       = 41
	GLOBAL CONSTANT SML_RFC_ERROR_TRIGGER            = 42

	GLOBAL CONSTANT SML_AFTER_MAP_ANALYSIS_TRIGGER   = 43
	GLOBAL CONSTANT SML_AFTER_MAP_COMPONENT_TRIGGER  = 44

	GLOBAL CONSTANT SML_ASSIGN_RESULT_TRIGGER        = 45
	GLOBAL CONSTANT SML_ASSIGN_RESLIST_TRIGGER       = 46

	GLOBAL CONSTANT SML_GET_LEVELS_TRIGGER           = 47
	GLOBAL CONSTANT SML_PRODUCT_FORMAT_TRIGGER       = 48
	GLOBAL CONSTANT SML_LOCATE_SAMPLE_TRIGGER        = 49
	GLOBAL CONSTANT SML_AFTER_LOCATE_SAMPLE_TRIGGER  = 50
	GLOBAL CONSTANT SML_LOCATE_JOB_TRIGGER           = 51
	GLOBAL CONSTANT SML_AFTER_LOCATE_JOB_TRIGGER     = 52
	GLOBAL CONSTANT SML_RESULT_CREATE_TRIGGER        = 53
	GLOBAL CONSTANT SML_CREATE_OBJECT_TRIGGER        = 54
	GLOBAL CONSTANT SML_TEST_CREATE_TRIGGER          = 55
	GLOBAL CONSTANT SML_NEXT_LOT_TRIGGER             = 56

	GLOBAL CONSTANT SML_PRODUCT_EMPTY_TRIGGER        = 57

	GLOBAL CONSTANT SML_COMPONENT_CREATE_TRIGGER     = 58
	GLOBAL CONSTANT SML_COMPONENT_UPDATE_TRIGGER     = 59
	GLOBAL CONSTANT SML_COMPONENT_DO_UPDATE_TRIGGER  = 60
	GLOBAL CONSTANT SML_COMPONENT_DO_CREATE_TRIGGER  = 61

	GLOBAL CONSTANT SML_ANALYSIS_CREATE_TRIGGER      = 62
	GLOBAL CONSTANT SML_ANALYSIS_NEW_VERS_TRIGGER    = 63
	GLOBAL CONSTANT SML_ANALYSIS_NEW_TRIGGER         = 64

	GLOBAL CONSTANT SML_SERIOUS_ERROR_TRIGGER        = 65

	GLOBAL CONSTANT SML_CL_HEADER_CREATE_TRIGGER     = 66
	GLOBAL CONSTANT SML_CL_ENTRY_CREATE_TRIGGER      = 67

	GLOBAL CONSTANT SML_RESULT_MISSING_TRIGGER       = 68
	GLOBAL CONSTANT SML_RESULT_FOUND_TRIGGER         = 69
	GLOBAL CONSTANT SML_TEST_ADD_TRIGGER             = 70

	GLOBAL CONSTANT SML_PROCESS_COMMIT_TRIGGER       = 71
	GLOBAL CONSTANT SML_PROCESS_POST_COMMIT_TRIGGER  = 72
	GLOBAL CONSTANT SML_PROCESS_ROLLBACK_TRIGGER     = 73

	GLOBAL CONSTANT CREATE_OBJECT_ROUTINE            = "create_sap_object"
	GLOBAL CONSTANT FAILURE_FILTER_ROUTINE           = "smidi_download_filter_callback"

	GLOBAL CONSTANT LIBRARY_POS                      = 1
	GLOBAL CONSTANT ROUTINE_POS                      = 2

	GLOBAL CONSTANT SMIDI_DEFAULT_LIBRARY            = "$SMIDI_USER"
	GLOBAL CONSTANT SMIDI_ROUTINE_FIELD              = "ROUTINE_NAME"
	GLOBAL CONSTANT SMIDI_LIBRARY_FIELD              = "LIBRARY_NAME"

{ Mapping }

	GLOBAL CONSTANT SMIDI_MAPPING_TABLE              = "SMIDI_MAP_ITEM"
	GLOBAL CONSTANT SMIDI_MAPPING_FIELD              = "SMP_NAME"
	GLOBAL CONSTANT SMIDI_MAPPING_INFO               = "STRUCTURE"
	GLOBAL CONSTANT SMIDI_MAPPING_DEFAULT            = "DEFAULT_VALUE"
	GLOBAL CONSTANT SMIDI_MAPPING_LEFT               = "NUMBER_LEFT"
	GLOBAL CONSTANT SMIDI_MAPPING_RIGHT              = "NUMBER_RIGHT"
	GLOBAL CONSTANT SMIDI_MAPPING_UPDATE             = "MAP_UPDATE"

{ Limits }

	GLOBAL CONSTANT GBI_LEVEL_POS                    = 1
	GLOBAL CONSTANT GBI_MINIMUM_POS                  = 2
	GLOBAL CONSTANT GBI_MAXIMUM_POS                  = 3
	GLOBAL CONSTANT GBI_PHRASE_POS                   = 4
	GLOBAL CONSTANT GBI_PASS_POS                     = 5
	GLOBAL CONSTANT GBI_CALCULATION_POS              = 6
	GLOBAL CONSTANT LESS_EQ                          = "<="
	GLOBAL CONSTANT GREAT_EQ                         = ">="

{ Upload }

	GLOBAL CONSTANT SMIDI_UPLOAD_UD                  = "LOT_UD"
	GLOBAL CONSTANT SMIDI_UPLOAD_POINT               = "POINT"
	GLOBAL CONSTANT SMIDI_UPLOAD_POINT_UD            = "POINT_UD"
	GLOBAL CONSTANT SMIDI_UPLOAD_RESULT              = "RESULT"
	GLOBAL CONSTANT SMIDI_UPLOAD_DEFECT              = "DEFECT" 

	GLOBAL CONSTANT SMIDI_NULL_KEY                   = "$NULL"
	GLOBAL CONSTANT SMIDI_ERROR_STATUS               = 3
	GLOBAL CONSTANT SMIDI_IGNORE_STATUS              = 2
	GLOBAL CONSTANT SMIDI_WAITING_STATUS             = 1

	GLOBAL CONSTANT LIMS_NUMERIC_TYPES               = "ADGJMP"
	GLOBAL CONSTANT LIMS_OPTIONAL_TYPES              = "BEHKNQ"
	GLOBAL CONSTANT LIMS_DEFECT_OR_BOOLEAN_TYPES     = "CFILOR"
	GLOBAL CONSTANT LIMS_UNKNOWN_RESULT_TYPE         = " "

	GLOBAL CONSTANT QMIDI_ALL_TYPES                  = "ABCDEFGHIJKLMNOPQR"

	GLOBAL CONSTANT SAP_MR_UPLOAD_TYPES              = "GHI"
	GLOBAL CONSTANT SAP_SR_MR_UPLOAD_TYPES           = "DEFPQR"
	GLOBAL CONSTANT SAP_SE_MR_UPLOAD_TYPES           = "ABCJKLMNO"

	GLOBAL CONSTANT SELECT_UPLOAD_2_SAP_ROUTINE      = "select_upload_2_sap"

	GLOBAL CONSTANT JOB_STATUS_Q88                   = "AC"              { list of status letters for job->lot ud upload   }
	GLOBAL CONSTANT JOB_STATUS_Q89                   = "XRS"             { list status letters job is that does lot cancel }

	GLOBAL CONSTANT MAXIMUM_RETRY_UPLOAD             = 10                { if config item empty   }
	GLOBAL CONSTANT SLEEP_TINY_AMOUNT                = "0 00:00:05.00"   { if results pending     }

{ Upload - optional result table fields that if in structure then are used in upload }

	GLOBAL CONSTANT SAP_ATTRIBUTE                    = "SAP_ATTRIBUTE"
	GLOBAL CONSTANT SAP_DOCUMENTATION                = "SAP_DOCUMENTATION"
	GLOBAL CONSTANT SAP_DEFECT_CLASS                 = "SAP_DEFECT_CLASS"
	GLOBAL CONSTANT SAP_RESULT_CONF_NO               = "SAP_RESULT_CONF_NO"
	GLOBAL CONSTANT SAP_RESULT_ORIGIN                = "SAP_RESULT_ORIGIN"
	GLOBAL CONSTANT SAP_SERIAL_NO                    = "SAP_SERIAL_NO"
	GLOBAL CONSTANT SAP_SPECIFICATION                = "SAP_SPECIFICATION"
	GLOBAL CONSTANT SAP_VALUATION                    = "SAP_VALUATION"
	GLOBAL CONSTANT SAP_SUBSAMP_DEFECT               = "SAP_SUBSAMP_DEFECT"
	

{ Background Constants }
CONSTANT BACKGROUND_LIBRARY = "$smidi_background"
CONSTANT BACKGROUND_LTE = "$smidi_lte_bg"
CONSTANT CREATE_SERVICE = "CREATE"
CONSTANT START_SERVICE = "START"
CONSTANT TYPE_ALL = ""
CONSTANT TYPE_DOWNLOAD = "DOWNLOAD"
CONSTANT TYPE_PROCESS = "PROCESS"
CONSTANT TYPE_UPLOAD = "UPLOAD"

{ ---------------------------------------------------------------------------- }
{* VARIABLES ******************************************************************}
{ ---------------------------------------------------------------------------- }

	declare         base_object     { Inherit from this key items          }
	declare         subsys_id       { R/3's name for SampleManager         }
	declare         r3sys_id        { SampleManager's name for R/3         }
	declare         config          { Configuration Items.                 }

	declare         debug_mode      { Debug level from base class          }
	declare         log_msgs        { Boolean if log of messages is ok     }
	declare         logfile_id      { Filename of the logfile for all msgs }
	declare         smidi_query     { What query is the base class for     }
	declare         smidi_server    { And the server for the base class    }
	declare         qmidi_object    { 1 or 2 (Feb 2002) for SAP objects    }
	declare         qmidi_version   { 46c if points enabled                }
	declare         mapping_profile { Default mapping profile              }

	declare         error_context   { the Error object for all routines    }
	declare         tmpString       { general temporary for passing params }
	declare         data_type       { the class name of the SAP objects    }
	declare         service   { the user/background id controller    }
	declare         retval          { Many routines return a value         }

	declare         spare           { alt_idi calls require this           }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_init ( VALUE a_user_pid_key0 )

	DECLARE colon_pos

	subsys_id        = "      "
	r3sys_id         = "          "
	logfile_id       = LIB_UTILS_LOGICAL_TO_STRING ( "smp$logfiles" ) : "\smidi.log"
	log_msgs         = TRUE
	debug_mode       = MSG_LOW
	smidi_server     = DEFAULT_SMIDI_SERVER
	smidi_query      = DEFAULT_SMIDI_QUERY
	qmidi_object     = DEFAULT_QMIDI_OBJECT
	qmidi_version    = DEFAULT_QMIDI_VERSION
	mapping_profile  = DEFAULT_MAPPING_PROFILE

	colon_pos        = INDEX ( a_user_pid_key0, ":" )

	{ ---------------------------------------------------------------------- }
	{ Theservice is a compound key of OPERATOR and ORDER_NUMBER       }
	{ Keep only the current process that is running in smidi_logfiles for it }
	{ ---------------------------------------------------------------------- }

	IF colon_pos > 0 THEN

		service = LEFTSTRING ( a_user_pid_key0, colon_pos - 1 ) : 
				    PACKED_DECIMAL ( RIGHTSTRING ( STRIP ( a_user_pid_key0 ), 1 ) )

	ELSE
		{ ---------------------------------------------------------------------- }
		{ Keep this user and number of attempts in foreground to see logfiles    }
		{ ---------------------------------------------------------------------- }

		colon_pos = SELECT MAX SMIDI_LOGFILES.ORDER_NUMBER WHERE SERVICE = OPERATOR
		

		IF colon_pos <> EMPTY THEN
			colon_pos = PACKED_DECIMAL ( colon_pos + 1 )
		ELSE
			colon_pos = PACKED_DECIMAL ( 1 )
		ENDIF

		service = OPERATOR : PACKED_DECIMAL(colon_pos)

	ENDIF

	{ ------------------------------------------------------ }
	{ service is the key into the smidi_logfiles table }
	{ ------------------------------------------------------ }

ENDROUTINE  { SMIDI_lib_init }

{******************************************************************************}

ROUTINE smidi_V2_action_set_inherit_from_start_stop ( self )

	log_msgs        = self.status_logging
	logfile_id      = self.status_filename
	smidi_query     = self.smidi_query
	smidi_server    = self.smidi_server
	debug_mode      = self.status_debug_mode

	mapping_profile = self.mapping_profile
	qmidi_object    = self.qmidi_object
	qmidi_version   = self.qmidi_version

ENDROUTINE { smidi_base_class_set_inherit_from_start_stop - called when query/server changes }

{******************************************************************************}

ROUTINE smidi_V2_action_get_inherit_from_lib ( self )

	IF ( VARIABLE_IS_ASSIGNED ( debug_mode ) ) THEN

		self.status_debug_mode    = debug_mode
		self.status_logging       = log_msgs
		self.status_filename      = logfile_id
		self.smidi_query          = smidi_query
		self.smidi_server         = smidi_server
		self.mapping_profile      = mapping_profile
		self.qmidi_object         = qmidi_object
		self.qmidi_version        = qmidi_version

	ELSE

		self.status_debug_mode    = 1
		self.status_logging       = TRUE
		self.status_filename      = LIB_UTILS_LOGICAL_TO_STRING ( "smp$textreports" ) : "\smidi.log"
		self.smidi_query          = DEFAULT_SMIDI_QUERY
		self.smidi_server         = DEFAULT_SMIDI_SERVER
		self.mapping_profile      = DEFAULT_MAPPING_PROFILE
		self.qmidi_object         = DEFAULT_QMIDI_OBJECT
		self.qmidi_version        = DEFAULT_QMIDI_VERSION

	ENDIF  { if the set has been done then these values are global variables in this library }

ENDROUTINE   { smidi_base_action_get_inherit_from_lib }

{******************************************************************************}
{                     S M I D I    B A S E    C L A S S                       *}
{******************************************************************************}

GLOBAL ROUTINE smidi_lib_sap_define_base_class ( VALUE qmidi_object )

	IF NOT class_defined ( SMIDI_BASE_CLASS ) THEN

		smidi_lib_SAP_structure_class( SMIDI_BASE_CLASS, qmidi_object )

		DEFINE CLASS SMIDI_BASE_CLASS INHERIT SMIDI_BASE_CLASS:"_":STRIP(qmidi_object)
		INITIALISATION
		ACTIONS

			"set_config"                  IN LIBRARY SMIDI_LIB_SAP , { Set this server/query config    }
			"set_inherit_from_start_stop" IN LIBRARY SMIDI_LIB_SAP , { inherit_from_base settings      }
			"get_inherit_from_lib"        IN LIBRARY SMIDI_LIB_SAP , { read ones set by start/stop     }

			"login"                       IN LIBRARY SMIDI_LIB_SAP , { Login to a SAP System.          }
			"logout"                      IN LIBRARY SMIDI_LIB_SAP , { Logout from the System.         }

			"get_library"                 IN LIBRARY SMIDI_LIB_SAP , { Get the Library Name.           }
			"get_routine"                 IN LIBRARY SMIDI_LIB_SAP , { Get the Routine Name.           }
			"add_trigger"                 IN LIBRARY SMIDI_LIB_SAP , { Add a Trigger.                  }
			"call_trigger"                IN LIBRARY SMIDI_LIB_SAP , { Trigger Handling Action         }

			"get_item"                    IN LIBRARY SMIDI_LIB_SAP , { Get a Config Item               }
			"get_map_header"              IN LIBRARY SMIDI_LIB_SAP , { Get a field from the map_header }

			"status_filter"               IN LIBRARY SMIDI_LIB_SAP , { Filter out unwanted messages    }
			"status_messages"             IN LIBRARY SMIDI_LIB_SAP , { Multiline Message Support       }
			"status_message"              IN LIBRARY SMIDI_LIB_SAP , { Send A Status Message out.      }
			"status_mess_decode"          IN LIBRARY SMIDI_LIB_SAP , { Message build then display      }

			"create_failure"              IN LIBRARY SMIDI_LIB_SAP , { Add a Failure Record.           }
			"add_failures"                IN LIBRARY SMIDI_LIB_SAP , { sap_err->call create_failure    }
			"add_vgl_failures"            IN LIBRARY SMIDI_LIB_SAP , { vgl_err->call create_failure    }
			"error_status"                IN LIBRARY SMIDI_LIB_SAP , { Error Status Support            }
			"rfc_error"                   IN LIBRARY SMIDI_LIB_SAP , { Handle an RFC Error.            }

			"continue"                    IN LIBRARY SMIDI_USER_LIB, { continue processing or not      }

			"send_RESULT"                 IN LIBRARY SMIDI_UPLOAD_USER_LIB, { Veto send or not     }
			"send_LOT_UD"                 IN LIBRARY SMIDI_UPLOAD_USER_LIB,
			"send_POINT_UD"               IN LIBRARY SMIDI_UPLOAD_USER_LIB,
			"send_POINT"                  IN LIBRARY SMIDI_UPLOAD_USER_LIB,
			"send_DEFECT"                 IN LIBRARY SMIDI_UPLOAD_USER_LIB 

		END CLASS { smidi_base_class }

		{ ---------------------------------------------------------------------- }
		{ The base class has the qirf sap object lengths for all SAP calls       }
		{ ---------------------------------------------------------------------- }

		smidi_lib_SAP_structure_class( SMIDI_QIRF_CLASS, qmidi_object )

		DEFINE CLASS SMIDI_QIRF_CLASS INHERIT SMIDI_QIRF_CLASS:"_":STRIP(qmidi_object)
		END CLASS

		{ ---------------------------------------------------------------------- }
		{ One of these days the mapping will be redone and part of the base      }
		{ ---------------------------------------------------------------------- }

		gbi_mapping_initialise(qmidi_object)


	ENDIF

ENDROUTINE { smidi_lib_sap_define_base_class }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_sap_define_download_class ( base_object, calling_report )

	gbi_login_initialise   ( base_object.qmidi_object )
	gbi_limits_initialise  ( base_object.qmidi_object )
	gbi_phrases_initialise ( base_object.qmidi_object )

	smidi_qails_init       ( base_object.qmidi_object )  { process & query, not points }
	smidi_qaipp_init       ( base_object.qmidi_object )  { points                      }
	smidi_qiwlr_init       ( base_object.qmidi_object )  { qiwlr worklist query table  }
 	error_context_init     ( base_object.qmidi_object )  { common to all query types   }

	smidi_lib_SAP_structure_class( SMIDI_DOWNLOAD_CLASS, base_object.qmidi_object )

	DEFINE CLASS SMIDI_DOWNLOAD_CLASS INHERIT SMIDI_BASE_CLASS, SMIDI_DOWNLOAD_CLASS:"_":STRIP(base_object.qmidi_object)
	INITIALISATION
	ACTIONS

		"process_a_query"   IN LIBRARY SMIDI_LIB_QPUP,        { Process a Query.             }
		"process_worklist"  IN LIBRARY SMIDI_LIB_QPUP,        { Process the Worklist.        }
		"TWO_stage"         IN LIBRARY SMIDI_LIB_QPUP,        { Two Stage Download.          }
		"ONE_stage"         IN LIBRARY SMIDI_LIB_QPUP,        { One Stage Download.          }

		"filter_callback"   IN LIBRARY SMIDI_LIB_QPUP,        { Filter Failure and worklist  }
		"filter_worklist"   IN LIBRARY SMIDI_LIB_QPUP,        { Filter Worklist              }
		"filter_failures"   IN LIBRARY SMIDI_LIB_QPUP,        { Filter out all the Failures. }
		"see_whats_left"    IN LIBRARY SMIDI_LIB_QPUP,        { After filters got anything?  }

		"store_lot_data"    IN LIBRARY SMIDI_LIB_QPUP,        { Fetch lot saves into sdque   }
		"store_point_data"  IN LIBRARY SMIDI_LIB_QPUP,        { and inspoints as well        }

		"qaica_qaivc_qaimv" IN LIBRARY SMIDI_LIB_QPUP,        { convert string to objects    }        
		"login_SAP_data"    IN LIBRARY SMIDI_LIB_QPUP,        { Perform the login of data    }

		"no_points_in_SAP"  IN LIBRARY SMIDI_POINT_USER_LIB,  { No points left               }
		"no_lots_in_SAP"    IN LIBRARY SMIDI_GET_LOT_USER_LIB,{ Nothing in SAP to get        }

		"add_failures"      IN LIBRARY SMIDI_LIB_SAP ,        { Add Failure Records.         }
		"create_failure"    IN LIBRARY SMIDI_LIB_SAP ,        { Add a Failure Record.        }
		"add_vgl_failures"  IN LIBRARY SMIDI_LIB_SAP ,        { Add VGL Failure Records.     }
		"download_error"    IN LIBRARY SMIDI_LIB_SAP          { ALT IDI SAP errors           }

	END CLASS { smidi_download_class }

	{ ============================================================================================== }
	{ This should execute every time and will allow the class to be displayed in COW as redefineable }
	{ ============================================================================================== }

	IF class_defined ( SMIDI_DOWNLOAD_CLASS ) THEN
		vgl_tools_class_redefinable ( SMIDI_DOWNLOAD_CLASS, TRUE )
	ENDIF


ENDROUTINE  { smidi_lib_define_download_class }

{******************************************************************************}

GLOBAL ROUTINE gbi_mapping_initialise ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "GBI_MAPPING", qmidi_object )

	DEFINE CLASS "GBI_MAPPING" INHERIT SMIDI_BASE_CLASS, "GBI_MAPPING_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"map_fields"         IN LIBRARY SMIDI_LIB_SAP , { Map fields from a table      }
		"map"                IN LIBRARY SMIDI_LIB_SAP , { Map using the Table Info     }
		"store_value"        IN LIBRARY SMIDI_LIB_SAP , { Store the Value              }
		"get_property"       IN LIBRARY SMIDI_LIB_SAP , { Get the Property.            }
		"search_property"    IN LIBRARY SMIDI_LIB_SAP , { GetProperty doin sum serchin }
		"table_map"          IN LIBRARY SMIDI_LIB_SAP , { Load Mapping from a Table    }
		"value_from_map"     IN LIBRARY SMIDI_LIB_SAP , { Map using a Property.        }
		"value_from_default" IN LIBRARY SMIDI_LIB_SAP , { Map to a Default Value.      }
		"value_from_routine" IN LIBRARY SMIDI_LIB_SAP   { Map using a Routine.         }

	END CLASS

ENDROUTINE    { gbi_mapping_intialise }

{******************************************************************************}

GLOBAL ROUTINE gbi_phrases_initialise ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "GBI_PHRASE_HEADER", qmidi_object )
	smidi_lib_SAP_structure_class( "GBI_PHRASE_ENTRY" , qmidi_object )

	DEFINE CLASS "GBI_PHRASE_HEADER" INHERIT "GBI_PHRASE_HEADER_":STRIP(qmidi_object)
	END CLASS

	DEFINE CLASS "GBI_PHRASE_ENTRY" INHERIT "GBI_PHRASE_ENTRY_":STRIP(qmidi_object)
	END CLASS

ENDROUTINE   { gbi_phrases_initialise }

{******************************************************************************}

GLOBAL ROUTINE gbi_limits_initialise ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "GBI_PRODUCT_HEADER", qmidi_object )
	smidi_lib_SAP_structure_class( "GBI_PRODUCT_ENTRY" , qmidi_object )

	DEFINE CLASS "GBI_PRODUCT_HEADER" INHERIT SMIDI_BASE_CLASS, "GBI_MAPPING", "GBI_PRODUCT_HEADER_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS        

		"new_mlp_link"      IN LIBRARY SMIDI_LIB_LIMITS,  { get the new entry code for the mlp                 }
		"assign_sap_levels" IN LIBRARY SMIDI_LIB_LIMITS,  { assigns the SAP levels to the mlp                  }
		"copy_lims_levels"  IN LIBRARY SMIDI_LIB_LIMITS,  { copy existing LIMS(only) levels previous version   }
		"id_exists"         IN LIBRARY SMIDI_LIB_LIMITS,  { checks if the id exists and is not removed         }
		"latest_version"    IN LIBRARY SMIDI_LIB_LIMITS,  { gets the most recent mlp version                   }
		"version_exists"    IN LIBRARY SMIDI_LIB_LIMITS,  { confirms that this version is real                 }
		"increment_version" IN LIBRARY SMIDI_LIB_LIMITS,  { increments the version for a new mlp/version       }
		"create_version"    IN LIBRARY SMIDI_LIB_LIMITS,  { creates the mlp as well as the new version         }
		"create_mlp"        IN LIBRARY SMIDI_LIB_LIMITS,  { only SMP <V4.1 (header and version 2 tables )      }
		"update_mlp_header" IN LIBRARY SMIDI_LIB_LIMITS,  { only SMP <V4.1 (updates the mlp header/new link)   }
		"copy_schedules"    IN LIBRARY SMIDI_LIB_LIMITS,  { copies the existing mlp schedules for a new mlp    }
		"copy_existing"     IN LIBRARY SMIDI_LIB_LIMITS,  { copy existing into limit_details (no table writes) }
		"insert_limits"     IN LIBRARY SMIDI_LIB_LIMITS,  { inserts the SAP limits into the object for verify  }
		"verify_limits"     IN LIBRARY SMIDI_LIB_LIMITS,  { checks each limit to make sure that matches lims   }
		"update_limits"     IN LIBRARY SMIDI_LIB_LIMITS   { updates the limits with the new values from SAP    }

	END CLASS


	DEFINE CLASS "GBI_PRODUCT_ENTRY" INHERIT SMIDI_BASE_CLASS, "GBI_MAPPING", "GBI_PRODUCT_ENTRY_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"verify_component"   IN LIBRARY SMIDI_LIB_LIMITS,
		"verify_limits"      IN LIBRARY SMIDI_LIB_LIMITS,
		"update_component"   IN LIBRARY SMIDI_LIB_LIMITS,
		"update_limits"      IN LIBRARY SMIDI_LIB_LIMITS,
		"upgrade_limits"     IN LIBRARY SMIDI_LIB_LIMITS,
		"create_component"   IN LIBRARY SMIDI_LIB_LIMITS,
		"copy_limit"         IN LIBRARY SMIDI_LIB_LIMITS,
		"create_limit"       IN LIBRARY SMIDI_LIB_LIMITS

	END CLASS

ENDROUTINE   { gbi_limits_initialise }

{******************************************************************************}

GLOBAL ROUTINE gbi_login_initialise ( VALUE qmidi_object )

	samp_job_initialise()

	smidi_lib_SAP_structure_class( "GBI_LOGIN"       , qmidi_object )
	smidi_lib_SAP_structure_class( "GBI_JOB_LOGIN"   , qmidi_object )
	smidi_lib_SAP_structure_class( "GBI_SAMPLE_LOGIN", qmidi_object )

	DEFINE CLASS "GBI_LOGIN" INHERIT "GBI_MAPPING", SMIDI_BASE_CLASS, "GBI_LOGIN_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"login_job"           IN LIBRARY SMIDI_LIB_LOGIN ,
		"login_sample"        IN LIBRARY SMIDI_LIB_LOGIN ,
		"build_template"      IN LIBRARY SMIDI_LIB_LOGIN ,
		"populate"            IN LIBRARY SMIDI_LIB_LOGIN ,
		"store_value"         IN LIBRARY SMIDI_LIB_LOGIN ,
		"low_level_job_login" IN LIBRARY SMIDI_LIB_LOGIN

	END CLASS


	DEFINE CLASS "GBI_JOB_LOGIN" INHERIT "GBI_LOGIN", SMIDI_BASE_CLASS, "GBI_JOB_LOGIN_":STRIP(qmidi_object)
	INITIALISATION
	END CLASS


	DEFINE CLASS "GBI_SAMPLE_LOGIN" INHERIT "GBI_LOGIN", SMIDI_BASE_CLASS, "GBI_SAMPLE_LOGIN":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"insert_test"         IN LIBRARY SMIDI_LIB_LOGIN   

	END CLASS

ENDROUTINE { gbi_login_initialise }

{******************************************************************************}

GLOBAL ROUTINE smidi_login_initialise ( VALUE qmidi_object )

	test_assn_initialise()

	smidi_lib_SAP_structure_class( "SMIDI_LOGIN"    , qmidi_object )
	smidi_lib_SAP_structure_class( "SMIDI_RQST"     , qmidi_object )
	smidi_lib_SAP_structure_class( "SMIDI_SAMP"     , qmidi_object )
	smidi_lib_SAP_structure_class( "SMIDI_TEST"     , qmidi_object )
	smidi_lib_SAP_structure_class( "SMIDI_COMPONENT", qmidi_object )


	DEFINE CLASS "SMIDI_LOGIN" INHERIT "GBI_MAPPING", SMIDI_BASE_CLASS, "SMIDI_LOGIN_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"verify_products_exist" IN LIBRARY SMIDI_LIB_LIMITS, { Check the Product is There. }
		"get_mlp_id"            IN LIBRARY SMIDI_LIB_LIMITS, { Get the Product ID          }
		"get_mlp_levels"        IN LIBRARY SMIDI_LIB_LIMITS, { Get the MLP Levels          }
		"format_mlp_id"         IN LIBRARY SMIDI_LIB_LIMITS, { Format the Product ID       }
		"update_product_specs"  IN LIBRARY SMIDI_LIB_LIMITS, { Update the Request.         }

		"update_analyses"       IN LIBRARY SMIDI_LIB_LOGIN , { Update the Analyses.        }
		"update_test_schedule"  IN LIBRARY SMIDI_LIB_LOGIN , { Update the Test Sched/entry }
		"update_tables"         IN LIBRARY SMIDI_LIB_LOGIN , { Update other map tables     }
 		"store_phrases"         IN LIBRARY SMIDI_LIB_LOGIN , { Store the Phrases.          }
		"process"               IN LIBRARY SMIDI_LIB_LOGIN , { Process                     }
		"process_tree"          IN LIBRARY SMIDI_LIB_LOGIN , { Process the Tree.           }
		"process_full_tree"     IN LIBRARY SMIDI_LIB_LOGIN , { Do all the Tree Processing. }
		"make_request_tree"     IN LIBRARY SMIDI_LIB_LOGIN , { Make the Request Tree.      }
		"store_request"         IN LIBRARY SMIDI_LIB_LOGIN   { Store the Values.           }      

	END CLASS


	DEFINE CLASS "SMIDI_RQST" INHERIT "GBI_MAPPING", SMIDI_BASE_CLASS, "SMIDI_RQST_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"format_analysis"      IN LIBRARY SMIDI_LIB_LOGIN, { Format the Analysis ID       }
		"format_component"     IN LIBRARY SMIDI_LIB_LOGIN, { Format the Component ID      }
		"process_test"         IN LIBRARY SMIDI_LIB_LOGIN, { Process a Test Record.       }
		"get_test_details"     IN LIBRARY SMIDI_LIB_LOGIN, { Get the Test Details.        }
		"insert_operation"     IN LIBRARY SMIDI_LIB_LOGIN, { Add an operation (QAIVC)     }
		"insert_material"      IN LIBRARY SMIDI_LIB_LOGIN, { Add material record (QAIVC)  }
		"build_sample_list"    IN LIBRARY SMIDI_LIB_LOGIN, { Build a list of samples      }
		"insert_samples"       IN LIBRARY SMIDI_LIB_LOGIN, { Insert samples               }
		"check_template"       IN LIBRARY SMIDI_LIB_LOGIN, { Check job/sample template    }
		"login_job"            IN LIBRARY SMIDI_LIB_LOGIN, { Login a job for the lot      }
		"login_smp_lot"        IN LIBRARY SMIDI_LIB_LOGIN, { SMP Lot login                }
		"login_sample_list"    IN LIBRARY SMIDI_LIB_LOGIN, { Login all the samples        }
		"login_sample"         IN LIBRARY SMIDI_LIB_LOGIN, { Login a sample.              }
		"qaipp_create_record"  IN LIBRARY SMIDI_LIB_LOGIN, { Create an inspection point   }
		"create_points_query"  IN LIBRARY SMIDI_LIB_LOGIN  { Create smidi points query    }

	END CLASS


	DEFINE CLASS "SMIDI_SAMP" INHERIT "GBI_MAPPING", SMIDI_BASE_CLASS, "SMIDI_SAMP_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"insert_test"          IN LIBRARY SMIDI_LIB_LOGIN, { Insert replicates of a test. }
		"insert_test_rep"      IN LIBRARY SMIDI_LIB_LOGIN, { Insert a test replicate      }
		"verify_tests"         IN LIBRARY SMIDI_LIB_LOGIN, { Required tests are created   }
		"verify_results"       IN LIBRARY SMIDI_LIB_LOGIN, { Required results are created }
		"add_smidi_insppoint"  IN LIBRARY SMIDI_LIB_LOGIN  { If IPoint sample make table  }

	END CLASS

	DEFINE CLASS "SMIDI_TEST" INHERIT "GBI_MAPPING", SMIDI_BASE_CLASS, "SMIDI_TEST_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"create"               IN LIBRARY SMIDI_LIB_LOGIN, { Create a new Test Record.    }
		"new_version"          IN LIBRARY SMIDI_LIB_LOGIN, { Create a new Analysis Vers.  }
		"resolve_list"         IN LIBRARY SMIDI_LIB_LOGIN, { Resolve SAP comps vs LIMS    }
		"build_anal_comp_list" IN LIBRARY SMIDI_LIB_LOGIN, { Build array from analysis    }
		"build_component_list" IN LIBRARY SMIDI_LIB_LOGIN, { Build array from a comp list }
		"verify"               IN LIBRARY SMIDI_LIB_LOGIN, { Verify Analysis Definition.  }
		"create_analysis"      IN LIBRARY SMIDI_LIB_LOGIN, { Create a new analysis        }
		"create_list"          IN LIBRARY SMIDI_LIB_LOGIN, { Create a new comp list       }
		"add_required_comp"    IN LIBRARY SMIDI_LIB_LOGIN, { Mark a result as required    }
		"verify_results"       IN LIBRARY SMIDI_LIB_LOGIN, { Ensure results are created   }

		"error_status"         IN LIBRARY SMIDI_LIB_SAP    { Error Status Messaging.      }

	END CLASS

	DEFINE CLASS "SMIDI_COMPONENT" INHERIT "GBI_MAPPING", SMIDI_BASE_CLASS, "SMIDI_COMPONENT_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"load"                 IN LIBRARY SMIDI_LIB_LOGIN, { Load a component object      }
		"set_from_qaimv"       IN LIBRARY SMIDI_LIB_LOGIN, { set component info from SAP  }
		"update_component"     IN LIBRARY SMIDI_LIB_LOGIN, { Update Components            }
		"create_component"     IN LIBRARY SMIDI_LIB_LOGIN, { Create Components            }
		"create_c_l_entry"     IN LIBRARY SMIDI_LIB_LOGIN, { Create a new c l entry       }
		"compatible"           IN LIBRARY SMIDI_LIB_LOGIN, { Compatible with the request? }
		"add_result"           IN LIBRARY SMIDI_LIB_LOGIN  { Create a result record       }

	END CLASS

ENDROUTINE  { smidi_login_intialise }

{******************************************************************************}

GLOBAL ROUTINE define_smidi_cnf_collection_class 

	DEFINE CLASS SMIDI_CNF_COLLECTION_CLASS INHERIT "STD_COLLECTION"
		INITIALISATION
		PROPERTIES
			"server"              ,    { The Server ID.            }
			"level_id"            ,    { Get Certain Config Types  }
			"query"                    { The Query ID.             }
		ACTIONS
			"load_data"           ,    { Load the Data.            }
			"load_items"          ,    { Load the Data.            }
			"add_config"          ,    { Add an Item to Collect.   }
			"make_config"         ,    { Insert a New Config Item  }
			"get_item"                 { Get the Value for an item }

	END CLASS { smidi_config_collection_class }

	{**********************************************************************}
	{* SMIDI Config Collected Class                                       *}
	{**********************************************************************}

	DEFINE CLASS SMIDI_CNF_COLLECTED_CLASS INHERIT "STD_COLLECTED"
		TABLES  smidi_config_header, smidi_config_item
		INITIALISATION
		PROPERTIES 
			"identity"            ,   { The Identity               }
			"server"              ,   { The Server ID.             }
			"deleted"             ,   { Has this been reverted?    }
			"query"               ,   { The Query ID.              }
			"value"                   { The Value                  }

	END CLASS { smidi_config_collected_class }

ENDROUTINE     { define_smidi_cnf_collection_class }

{******************************************************************************}

ROUTINE smidi_V2_class_initialisation ( self )

	DECLARE arec, save_vers

	self.A1_base           = "Not applicable"

	self.parent            = EMPTY
	self.structure         = EMPTY
	self.base_user         = EMPTY
	self.user_info         = EMPTY
	self.config            = EMPTY
	self.error_msg         = EMPTY
	self.error_num         = EMPTY
	self.smidi_qirf        = EMPTY

	self.work_done         = FALSE
	self.status_logging    = TRUE
	self.status_debug_mode = 1
	self.status_filename   = LIB_UTILS_LOGICAL_TO_STRING ( "smp$logfiles" ) : "\smidi.log"
	self.smidi_server      = DEFAULT_SMIDI_SERVER
	self.smidi_query       = DEFAULT_SMIDI_QUERY
	self.service     = service


	ARRAY self.trigger
		self.add_trigger ( "TRIGGER_TRIGGER"         , SMIDI_USER_LIB, GBI_MAPPING_TRIGGER_TRIGGER )
		self.add_trigger ( "smidi_lib_user_rfc_error", SMIDI_USER_LIB, SML_RFC_ERROR_TRIGGER       )

	{ ------------------------------------------------------ }
	{ Start/Stop is a new query, so set new config items     }
	{ ------------------------------------------------------ }

	tmpString = SMIDI_BASE_CLASS # "_"

	IF ( object_get_class_name ( self ) = tmpString ) THEN

		config               = smidi_lib_get_config ( self.smidi_server, self.smidi_query )
		self.config          = config
		self.config.query    = DEFAULT_SMIDI_QUERY
		self.config.server   = DEFAULT_SMIDI_SERVER
		base_object          = self

		{ ------------------------------------------------------------------- }
		{ Load every imaginable config item from all types 1 time only        }
		{ ------------------------------------------------------------------- }

		arec = SELECT SMIDI_SYSTEM.IDENTITY WHERE REMOVEFLAG = FALSE

		WHILE arec <> EMPTY DO

			smidi_lib_config_item ( "ALL", arec, "DEFAULT" )
			NEXT SMIDI_SYSTEM
			arec = SELECT SMIDI_SYSTEM.IDENTITY

		ENDWHILE


		arec = SELECT SMIDI_QUERY.IDENTITY WHERE REMOVEFLAG = FALSE

		WHILE arec <> EMPTY DO

			tmpString = SELECT SMIDI_QUERY.SMIDI_SYSTEM

			smidi_lib_config_item ( "ALL", tmpString, arec )

			NEXT SMIDI_QUERY
			arec = SELECT SMIDI_QUERY.IDENTITY

		ENDWHILE

		{ ------------------------------------------------------------------- }
		{ Get the minimum items from the default server on the system         }
		{ ------------------------------------------------------------------- }

		self.qmidi_object    = DEFAULT_QMIDI_OBJECT
		self.qmidi_version   = DEFAULT_QMIDI_VERSION
		self.mapping_profile = DEFAULT_MAPPING_PROFILE

		{ ------------------------------------------------------------------- }
		{ Load every imaginable QIRF and SAP object parameters                }
		{ ------------------------------------------------------------------- }

		ARRAY self.smidi_qirf
		CREATE OBJECT SMIDI_QIRF_CLASS, self.smidi_qirf[1]

		arec = SELECT SMIDI_STRUCTURE.IDENTITY WHERE REMOVEFLAG = FALSE AND SAP_SUM_LENGTH > 0
			ORDER ON SAP_VERSION, IDENTITY

		WHILE arec <> EMPTY DO

			tmpString                         = SELECT SMIDI_STRUCTURE.SAP_VERSION
			self.smidi_qirf[tmpString].?arec? = SELECT SMIDI_STRUCTURE.SAP_SUM_LENGTH

			NEXT SMIDI_STRUCTURE
			arec      = SELECT SMIDI_STRUCTURE.IDENTITY
			tmpString = SELECT SMIDI_STRUCTURE.SAP_VERSION

			IF NOT ( VARIABLE_IS_ASSIGNED ( save_vers ) ) THEN

				save_vers = tmpString

			ELSEIF ( tmpString <> EMPTY ) & ( tmpString > save_vers ) THEN

				save_vers = tmpString
				CREATE OBJECT SMIDI_QIRF_CLASS, self.smidi_qirf[tmpString]

			ENDIF

		ENDWHILE


	ELSE

		self.config            = EMPTY                         { <- only base object needs this mess }
		self.qmidi_object      = base_object.qmidi_object      { <- inherit these from base object   }
		self.qmidi_version     = base_object.qmidi_version
		self.mapping_profile   = base_object.mapping_profile
		self.service     = base_object.service
		self.smidi_server      = base_object.smidi_server
		self.smidi_query       = base_object.smidi_query
		self.status_debug_mode = base_object.status_debug_mode
		self.status_filename   = base_object.status_filename

	ENDIF

ENDROUTINE { smidi_base_class_initialisation }

{******************************************************************************}

ROUTINE smidi_download_class_initialisation ( self )

	self.config    = EMPTY
	self.orig_from = "000000000000"
	self.orig_to   = "999999999999"

	self.get_inherit_from_lib()

ENDROUTINE { smidi_download_class_initialisation }

{******************************************************************************}

ROUTINE gbi_mapping_class_initialisation( self )

	self.parent           = EMPTY
	self.map_default      = EMPTY
	self.map_library      = EMPTY
	self.map_routine      = EMPTY
	self.map_value        = EMPTY
	self.map_property     = EMPTY
	self.mapping_table    = EMPTY
	self.mapping_field    = EMPTY
	self.mapping_routine  = EMPTY
	self.mapping_library  = EMPTY
	self.mapping_info     = EMPTY
	self.mapping_default  = EMPTY
	self.routine_field    = EMPTY
	self.library_field    = EMPTY
	self.current_table    = EMPTY
	self.map_lims_table   = EMPTY
	self.map_lims_field   = EMPTY

	self.mapping_left     = EMPTY
	self.mapping_right    = EMPTY
	self.mapping_update   = EMPTY

	self.number_left      = EMPTY
	self.number_right     = EMPTY
	self.map_update       = EMPTY

	self.get_inherit_from_lib()

ENDROUTINE  { gbi_mapping_class_initialisation( self ) }

{******************************************************************************}

ROUTINE gbi_product_header_class_initialisation ( self )

	self.product_id       = ""
	self.product_version  = 1

	self.mlp_update       = self.get_map_header ( "MLP_UPDATE"         )
	self.check_mlp_target = self.get_map_header ( "MLP_TARGET"         )
	self.check_mlp_units  = self.get_map_header ( "MLP_UNITS"          )
	self.check_mlp_type   = self.get_map_header ( "MLP_TYPE"           )
	self.check_mlp_places = self.get_map_header ( "MLP_PLACES"         )
	self.copy_comps       = self.get_map_header ( "MLP_COPY_LIMS_ONLY" )
	self.copy_schedules   = self.get_map_header ( "MLP_COPY_LIMS_ONLY" )

	self.parent           = EMPTY
	self.master           = EMPTY
	self.copy_version     = EMPTY
	self.copy_entry_code  = EMPTY

	self.versioned_header = valid_field ( "MLP_HEADER", "PRODUCT_VERSION" )

	ARRAY self.components 

	self.get_inherit_from_lib()

	self.add_trigger ( "PRODUCT_CHECK_HEADER"     , SMIDI_PROCESS_USER_LIB, GBI_CHECK_MLP_TRIGGER         )
	self.add_trigger ( "PRODUCT_CHECK_VERSION"    , SMIDI_PROCESS_USER_LIB, GBI_CHECK_MLP_VERSION_TRIGGER )
	self.add_trigger ( "PRODUCT_NEW_MLP"          , SMIDI_PROCESS_USER_LIB, GBI_NEW_MLP_TRIGGER           )
	self.add_trigger ( "PRODUCT_COPY_SCHEDULE"    , SMIDI_PROCESS_USER_LIB, GBI_COPY_SCHEDULE_TRIGGER     )
	self.add_trigger ( "PRODUCT_DO_COPY_SCHEDULE" , SMIDI_PROCESS_USER_LIB, GBI_DO_COPY_SCHED_TRIGGER     )
	self.add_trigger ( "PRODUCT_NEW_VERSION"      , SMIDI_PROCESS_USER_LIB, GBI_NEW_VERSION_TRIGGER       )
	self.add_trigger ( "PRODUCT_NEW_LEVEL"        , SMIDI_PROCESS_USER_LIB, GBI_NEW_LEVEL_TRIGGER         )
	self.add_trigger ( "PRODUCT_ASSIGN_LEVEL"     , SMIDI_PROCESS_USER_LIB, GBI_ASSIGN_LEVEL_TRIGGER      )
	self.add_trigger ( "PRODUCT_ASSIGN_LEVELS"    , SMIDI_PROCESS_USER_LIB, GBI_ASSIGN_LEVELS_TRIGGER     )
	self.add_trigger ( "PRODUCT_UPDATE_LIMITS"    , SMIDI_PROCESS_USER_LIB, GBI_UPDATE_LIMITS_TRIGGER     )
	self.add_trigger ( "PRODUCT_DO_COPY_COMPONENT", SMIDI_PROCESS_USER_LIB, GBI_DO_COPY_COMPONENT_TRIGGER )

ENDROUTINE { gbi_product_header_class_initialisation }


{******************************************************************************}

ROUTINE gbi_product_entry_class_initialisation ( self )

	self.add_trigger ( "PRODUCT_CHECK_COMPONENT"  , SMIDI_PROCESS_USER_LIB, GBI_CHECK_COMPONENT_TRIGGER )
	self.add_trigger ( "PRODUCT_NEW_COMPONENT"    , SMIDI_PROCESS_USER_LIB, GBI_NEW_COMPONENT_TRIGGER   )
	self.add_trigger ( "PRODUCT_VERIFY_LIMIT"     , SMIDI_PROCESS_USER_LIB, GBI_VERIFY_LIMITS_TRIGGER   )
	self.add_trigger ( "PRODUCT_NEW_LIMIT"        , SMIDI_PROCESS_USER_LIB, GBI_NEW_LIMIT_TRIGGER       )
	self.add_trigger ( "PRODUCT_COPY_LIMIT"       , SMIDI_PROCESS_USER_LIB, GBI_COPY_LIMIT_TRIGGER      )
	self.add_trigger ( "PRODUCT_DO_COPY_LIMIT"    , SMIDI_PROCESS_USER_LIB, GBI_DO_COPY_LIMIT_TRIGGER   )
	self.add_trigger ( "PRODUCT_COPY_COMPONENT"   , SMIDI_PROCESS_USER_LIB, GBI_COPY_COMPONENT_TRIGGER  )

	ARRAY self.levels

	self.get_inherit_from_lib()

ENDROUTINE { gbi_product_entry_class_initialisation }

{******************************************************************************}

ROUTINE gbi_login_class_initialisation( self )

	self.master           = EMPTY
	self.is_job           = EMPTY

	self.template_id      = " "
	self.job_identity     = " "
	self.job_syntax       = " "
	self.sample_syntax    = " "

	self.fields_added     = 0

	self.get_inherit_from_lib()

ENDROUTINE   { gbi_login_class_initialisation }

{******************************************************************************}

ROUTINE gbi_job_login_class_initialisation( self )

	self.get_inherit_from_lib()

ENDROUTINE   { gbi_job_login_class_initialisation }

{******************************************************************************}

ROUTINE gbi_sample_login_class_initialisation( self )

	self.get_inherit_from_lib()

ENDROUTINE   { gbi_sample_login_class_initialisation }

{******************************************************************************}

ROUTINE smidi_rqst_class_initialisation ( self )

	ARRAY self.operations
	ARRAY self.materials
	ARRAY self.samples

	self.ops_count = 0
	self.parent    = EMPTY
	self.lot_id    = EMPTY

	self.get_inherit_from_lib()

	self.add_trigger ( "ANALYSIS_MAP_AFTER" , SMIDI_PROCESS_USER_LIB, SML_AFTER_MAP_ANALYSIS_TRIGGER  )
	self.add_trigger ( "COMPONENT_MAP_AFTER", SMIDI_PROCESS_USER_LIB, SML_AFTER_MAP_COMPONENT_TRIGGER )

ENDROUTINE { smidi_rqst_class_initialisation }

{******************************************************************************}

ROUTINE smidi_samp_class_initialisation ( self )

	DECLARE mt
	mt = EMPTY
	smidi_lib_initialise_mapping ( self, mt )

	self.get_inherit_from_lib()

	self.add_trigger ( "TEST_ASSIGN_RESULT", SMIDI_PROCESS_USER_LIB, SML_ASSIGN_RESULT_TRIGGER  )

ENDROUTINE { smidi_samp_class_initialisation }

{******************************************************************************}

ROUTINE smidi_test_class_initialisation ( self )

	DECLARE mt

	mt = EMPTY
	smidi_lib_initialise_mapping ( self, mt )
	self.new_version = FALSE

	self.get_inherit_from_lib()

	self.add_trigger ( "TEST_ASSIGN_RESULT",           SMIDI_PROCESS_USER_LIB, SML_ASSIGN_RESULT_TRIGGER     )
	self.add_trigger ( "TEST_ASSIGN_LIST_RESULT",      SMIDI_PROCESS_USER_LIB, SML_ASSIGN_RESLIST_TRIGGER    )
	self.add_trigger ( "TEST_CREATE",                  SMIDI_PROCESS_USER_LIB, SML_TEST_CREATE_TRIGGER       )
	self.add_trigger ( "TEST_ADD",                     SMIDI_PROCESS_USER_LIB, SML_TEST_ADD_TRIGGER          )
	self.add_trigger ( "ANALYSIS_CREATE",              SMIDI_PROCESS_USER_LIB, SML_ANALYSIS_CREATE_TRIGGER   )
	self.add_trigger ( "ANALYSIS_NEW_VERSION",         SMIDI_PROCESS_USER_LIB, SML_ANALYSIS_NEW_VERS_TRIGGER )
	self.add_trigger ( "ANALYSIS_DO_NEW_VERSION",      SMIDI_PROCESS_USER_LIB, SML_ANALYSIS_NEW_TRIGGER      )
	self.add_trigger ( "COMPONENT_LIST_HEADER_CREATE", SMIDI_PROCESS_USER_LIB, SML_CL_HEADER_CREATE_TRIGGER  )

ENDROUTINE { smidi_test_class_initialisation }

{******************************************************************************}

ROUTINE smidi_component_class_initialisation ( self )

        self.qaimv              = EMPTY
        self.name               = ""
        self.result_type        = ""
        self.units              = ""
        self.minimum            = ""
        self.maximum            = ""
        self.true_word          = ""
        self.false_word         = ""
        self.allowed_characters = ""
        self.calculation        = ""
        self.places             = ""
        self.rep_control        = ""
        self.replicates         = ""
        self.sig_figs_number    = ""
        self.sig_figs_rounding  = ""
        self.sig_figs_filter    = ""
        self.minimum_pql        = ""
        self.maximum_pql        = ""
        self.pql_calculation    = ""
        self.formula            = ""

        smidi_lib_initialise_mapping ( self, self.qaimv )

	self.get_inherit_from_lib()

        self.add_trigger ( "TEST_ASSIGN_RESULT",          SMIDI_PROCESS_USER_LIB, SML_ASSIGN_RESULT_TRIGGER        )
        self.add_trigger ( "RESULT_CREATE",               SMIDI_PROCESS_USER_LIB, SML_RESULT_CREATE_TRIGGER        )
        self.add_trigger ( "RESULT_MISSING",              SMIDI_PROCESS_USER_LIB, SML_RESULT_MISSING_TRIGGER       )
        self.add_trigger ( "RESULT_FOUND",                SMIDI_PROCESS_USER_LIB, SML_RESULT_FOUND_TRIGGER         )
        self.add_trigger ( "COMPONENT_CREATE",            SMIDI_PROCESS_USER_LIB, SML_COMPONENT_CREATE_TRIGGER     )
        self.add_trigger ( "COMPONENT_UPDATE",            SMIDI_PROCESS_USER_LIB, SML_COMPONENT_UPDATE_TRIGGER     )
        self.add_trigger ( "COMPONENT_DO_CREATE",         SMIDI_PROCESS_USER_LIB, SML_COMPONENT_DO_CREATE_TRIGGER  )
        self.add_trigger ( "COMPONENT_DO_UPDATE",         SMIDI_PROCESS_USER_LIB, SML_COMPONENT_DO_UPDATE_TRIGGER  )
        self.add_trigger ( "COMPONENT_LIST_ENTRY_CREATE", SMIDI_PROCESS_USER_LIB, SML_C_L_ENTRY_CREATE_TRIGGER     )

ENDROUTINE { smidi_component_class_initialisation }

{******************************************************************************}

ROUTINE smidi_login_class_initialisation ( self )

	self.parent      = EMPTY
	self.operations  = EMPTY
	self.chars       = EMPTY
	self.config      = EMPTY
	self.phrases     = EMPTY
	self.product_id  = EMPTY
	self.product_ver = EMPTY
	self.part_sample = EMPTY
	self.point_mode  = FALSE     { <- only set true in process/login if point being processed }

	ARRAY self.tree

	self.get_inherit_from_lib()

	self.add_trigger ( "PRODUCT_GET_NEW_LEVELS", SMIDI_PROCESS_USER_LIB, SML_GET_LEVELS_TRIGGER     )
	self.add_trigger ( "PRODUCT_FORMAT_ID",      SMIDI_PROCESS_USER_LIB, SML_PRODUCT_FORMAT_TRIGGER )
	self.add_trigger ( "PRODUCT_MAPPED_EMPTY",   SMIDI_PROCESS_USER_LIB, SML_PRODUCT_EMPTY_TRIGGER  )

ENDROUTINE { smidi_login_class_initialisation }

{*******************************************************************************
*               S M I D I   C N F   C O L L E C T I O N                       
*******************************************************************************}

ROUTINE smidi_cnf_collection_class_initialisation ( self )

	self.server    = EMPTY
	self.query     = EMPTY
	self.level_id  = EMPTY
	self.add_index ( "IDENTITY"  )

ENDROUTINE { smidi_cnf_collection_class_initialisation }

{*******************************************************************************
*                 S M I D I   C N F   C O L L E C T E D
*******************************************************************************}

ROUTINE smidi_cnf_collected_class_initialisation ( self )

	self.identity = EMPTY
	self.server   = EMPTY
	self.query    = EMPTY
	self.value    = EMPTY
	self.deleted  = FALSE

ENDROUTINE { smidi_cnf_collected_class_initialisation }

{******************************************************************************}
{******************************************************************************}
{                                                                              }
{                                                                              }
{     I N I T I A L I Z A T I O N    O F    S A P    O B J E C T S             }
{                                                                              }
{                                                                              }
{******************************************************************************}
{                                                                              }
{                                                                              }
{            D  O  W  N  L  O  A  D      O  B  J  E  C  T  S                   }
{                                                                              }
{ QAILS - worklist selection on download                                       }
{ QIWLR - worklist retrieved using selection                                   }
{ QAICA - phrases                                                              }
{ QAIVC - operations                                                           }
{ QAIMV - characteristics                                                      }
{ QAIPP - inspection points                                                    }
{ QIERR - errors                                                               }
{ QEIFT - catalog types                                                        }
{                                                                              }
{                                                                              }
{******************************************************************************}
{******************************************************************************}

{******************************************************************************}

GLOBAL ROUTINE smidi_qails_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class ( "QAILS", qmidi_object )
	smidi_lib_SAP_structure_class ( "QMGET", qmidi_object )
	
	DEFINE CLASS "QAILS" INHERIT SMIDI_BASE_CLASS, "QAILS_":STRIP(qmidi_object)
	INITIALISATION
	END CLASS

	DEFINE CLASS "QMGET" INHERIT SMIDI_BASE_CLASS, "QMGET_":STRIP(qmidi_object)
	PROPERTIES
		"qails"             , { Selection criteria object                        }
		"filter_routine"    , { Routine to filter worklist                       }
		"filter_library"    , { Library in which filter_routine exists           }
		"process_routine"   , { Routine to process downloaded work               }
		"process_library"   , { Library in which process_routine exists          }
		"repeat_interval"   , { Defines frequency that the query is issued       }
		"sort_ascending"    , { Sort worklist/operations oldest to newest        }
		"sort_descending"   , { Sort worklist/operations newest to oldest        }
		"allow_corrections" , { Allow download of corrections to processed items }
		"lock_chars"        , { Download using a write transaction, locks in R/3 }
		"get_required"      , { Download only mandatory characteristics          }
		"get_valuation"     , { Download valuation details                       }
		"get_res_cat"       , { Download phrase data for results                 }
		"get_ud_cat"        , { Download phrase data for usage decisions         }
		"get_work_centre"   , { Download information about the work centre       }
		"get_vendor"        , { Download information about the vendor            }
		"get_purchasing"    , { Download data from the purchasing records        }
		"get_sales"         , { Download data from the sales records             }
		"next_call"         , { Date and time the query will be issued next      }
		"none_left"         , { If SAP returns NO_ENTRY set query as none left   }
		"fetch_query"       , { The fetch query is written to the download queue }
		"from_ip_lot"       , { For Inspection Points only, sets lot to fetch    }
		"from_ip_op_no"     , { "   "          "      "   , sets operation       }
		"from_ip_point"     , { "   "          "      "   , starting point       }
		"to_ip_point"       , { "   "          "      "   , ending point         }
		"smidi_subsystem"   , { "   "          "      "   , QDR subsystem        }
		"do_2_stage"          { Boolean do 1 or 2 stage download                 }
	END CLASS

ENDROUTINE  { smidi_qails_init }

{******************************************************************************}

GLOBAL ROUTINE smidi_qiwlr_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QIWLR", qmidi_object )

	DEFINE CLASS "QIWLR" INHERIT SMIDI_BASE_CLASS, "QIWLR_":STRIP(qmidi_object)
	INITIALISATION
	END CLASS

	IF class_defined ( "QIWLR" ) THEN
		vgl_tools_class_redefinable ( "QIWLR", TRUE )  { allow multiple process queries }
	ENDIF

ENDROUTINE  { smidi_qiwlr_init }

{******************************************************************************}

GLOBAL ROUTINE smidi_qaica_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QAICA", qmidi_object )

	DEFINE CLASS "QAICA" INHERIT SMIDI_BASE_CLASS, "QAICA_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"cleanup"      IN LIBRARY SMIDI_LIB_PHRASE, { Clear out phrases before load }
		"create"       IN LIBRARY SMIDI_LIB_PHRASE, { Create phrase table           }
		"add_phrase"   IN LIBRARY SMIDI_LIB_PHRASE  { Add a phrase to phrase table  }

	END CLASS

ENDROUTINE   { smidi_qaica_init }

{******************************************************************************}

GLOBAL ROUTINE smidi_qaivc_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QAIVC", qmidi_object )

	DEFINE CLASS "QAIVC" INHERIT "GBI_MAPPING", SMIDI_BASE_CLASS, "QAIVC_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"create_record"   IN LIBRARY SMIDI_LIB_SAP  , { Create smidi_request_record         }
		"remove_record"   IN LIBRARY SMIDI_LIB_CLEAN, { Delete a QAIVC in temporary storage }
		"remove_ips"      IN LIBRARY SMIDI_LIB_CLEAN  { Delete inspection point records     }

	END CLASS

ENDROUTINE   { smidi_qaivc_init ( VALUE qmidi_object ) }

{******************************************************************************}

GLOBAL ROUTINE smidi_qaimv_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QAIMV", qmidi_object )

	DEFINE CLASS "QAIMV" INHERIT "GBI_PRODUCT_ENTRY", SMIDI_BASE_CLASS, "QAIMV_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"create_record"          IN LIBRARY SMIDI_LIB_SAP   , { Create smidi_request_header                }
		"get_result_type"        IN LIBRARY SMIDI_LIB_SAP   , { Get the result type for characteristic     }
		"get_test_counts"        IN LIBRARY SMIDI_LIB_SAP   , { Calculate test replicates partial samples  }
		"get_upload_type"        IN LIBRARY SMIDI_LIB_SAP   , { Get the upload record type for a char      }

		"get_mlp_component"      IN LIBRARY SMIDI_LIB_LIMITS, { Get the MLP Component Information          }
		"get_level_info"         IN LIBRARY SMIDI_LIB_LIMITS, { Map the Level Information.                 }
		"get_level_info_n"       IN LIBRARY SMIDI_LIB_LIMITS, { Deal with Numeric limit types.             }

		"remove_record"          IN LIBRARY SMIDI_LIB_CLEAN, { Delete QAIMV from temporary storage        }

		"get_phrase"             IN LIBRARY SMIDI_LIB_PHRASE  { Get the result entry phrase type for char  }

	END CLASS

ENDROUTINE     { smidi_qaimv_init ( VALUE qmidi_object ) }

{******************************************************************************}

GLOBAL ROUTINE smidi_qaipp_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QAIPP", qmidi_object )

	DEFINE CLASS "QAIPP" INHERIT SMIDI_BASE_CLASS, "QAIPP_":STRIP(qmidi_object)
	INITIALISATION
	END CLASS

ENDROUTINE         { smidi_qaipp_init ( VALUE qmidi_object ) }

{******************************************************************************}

GLOBAL ROUTINE smidi_qierr_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QIERR", qmidi_object )

	DEFINE CLASS "QIERR" INHERIT SMIDI_BASE_CLASS, "QIERR_":STRIP(qmidi_object)
	INITIALISATION
	ACTIONS

		"format_message"   IN LIBRARY SMIDI_LIB_SAP,  { Format the Message Nicely.              }
		"build_message"    IN LIBRARY SMIDI_LIB_SAP,  { Build the Error Message                 }
		"is_serious"       IN LIBRARY SMIDI_LIB_SAP,  { Determine whether the error is serious  }
		"report"           IN LIBRARY SMIDI_LIB_SAP,  { Report the error                        }
		"clear"            IN LIBRARY SMIDI_LIB_SAP,  { Clear the LIMS ONLY information         }
		"add_data"         IN LIBRARY SMIDI_LIB_SAP   { Fill in LIMS data                       }

	END CLASS

ENDROUTINE          { smidi_qierr_init ( VALUE qmidi_object )  }

{******************************************************************************}

GLOBAL ROUTINE smidi_qeift_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QEIFT", qmidi_object )

	DEFINE CLASS "QEIFT" INHERIT SMIDI_BASE_CLASS, "QEIFT_":STRIP(qmidi_object)
	INITIALISATION
	END CLASS

ENDROUTINE  { smidi_qeift_init }


{ ---------------------------------------------------------------------------- }
{                                                                              }
{                                                                              }
{           INITIALISATION ROUTINES FOR THE SAP DOWNLOAD CLASSES               }
{                                                                              }
{                                                                              }
{ ---------------------------------------------------------------------------- }


{******************************************************************************}

ROUTINE qails_class_initialisation(self)

	self.record_type     = pad("Q40"," ",3)
	self.from_lot_no     = pad("0","0",12)
	self.to_lot_no       = pad("9","9",12)
	self.op_sequence     = pad(" "," ",6)
	self.from_op_no      = pad(" "," ",4)
	self.to_op_no        = pad(" "," ",4)
	self.op_plant        = pad(" "," ",4)
	self.subsystem       = pad(" "," ",6)
	self.work_centre     = pad(" "," ",8)
	self.wc_plant        = pad(" "," ",4)
	self.material_no     = pad(" "," ",18)
	self.from_date       = pad(" "," ",8)
	self.to_date         = pad(" "," ",8)
	self.insp_status     = pad(" "," ",1)
	self.inspection_type = pad(" "," ",8)
	self.origin          = pad(" "," ",2)
	self.batch_no        = pad(" "," ",10)
	self.from_order_no   = pad(" "," ",12)
	self.to_order_no     = pad(" "," ",12)
	self.vendor_no       = pad(" "," ",10)
	self.customer_no     = pad(" "," ",10)
	self.mat_doc_no      = pad(" "," ",10)
	self.max_lots        = pad("0","0",4)

	self.get_inherit_from_lib()

ENDROUTINE  { qails_class_initialisation }

{******************************************************************************}

ROUTINE qiwlr_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qiwlr_class_initialisation }

{******************************************************************************}

ROUTINE qaica_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qaica_class_initialisation }

{******************************************************************************}

ROUTINE qaivc_class_initialisation ( self )

	CREATE OBJECT "GBI_PRODUCT_HEADER", self.product_object
	CREATE OBJECT "GBI_JOB_LOGIN"     , self.job
	CREATE OBJECT "GBI_SAMPLE_LOGIN"  , self.sample

	smidi_lib_initialise_mapping ( self.product_object, self        )
	smidi_lib_initialise_mapping ( self.job           , self        )
	smidi_lib_initialise_mapping ( self.sample        , self        )
	smidi_lib_initialise_mapping ( self               , self.sample )    { <--- allow smidi_request_header map }

	self.product_id   = EMPTY
	self.qiwlr        = EMPTY
	self.error_msg    = EMPTY
	self.error_num    = EMPTY

	self.get_inherit_from_lib()

	self.requestor = self.smidi_server   { inherit sets correct id }

ENDROUTINE { qaivc_class_initialisation }

{******************************************************************************}

ROUTINE qaimv_class_initialisation (self)

	smidi_lib_initialise_mapping ( self, self.parent )                   { <---- allow smidi_request_record map }

	self.get_inherit_from_lib()

ENDROUTINE { qaimv_class_initialisation }

{******************************************************************************}

ROUTINE qaipp_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qaipp_class_initialisation }

{******************************************************************************}

ROUTINE qierr_class_initialisation (self)

	self.serious     = FALSE
	self.counter     = "001"
	self.add_trigger ( "smidi_lib_user_serious_error", SMIDI_USER_LIB, SML_SERIOUS_ERROR_TRIGGER   )

	self.get_inherit_from_lib()

ENDROUTINE      { qierr_class_initalisation }

{******************************************************************************}

ROUTINE qeift_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qeift_class_initialisation }

{******************************************************************************}

GLOBAL ROUTINE error_context_init ( VALUE qmidi_object )

	tmpString = "ALL"

	smidi_qierr_init( qmidi_object )

	CREATE OBJECT "QIERR", error_context
	error_context_clear( tmpString )

	RETURN ( error_context )

ENDROUTINE   { error_context_init }

{******************************************************************************}

GLOBAL ROUTINE error_context_get

	RETURN ( error_context )

ENDROUTINE { error_context_get }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                 U P L O A D  ( S M I D I )   O B J E C T S                   }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE define_smidi_queue_class ( VALUE version )

	smidi_lib_SAP_structure_class( SMIDI_QUEUE_CLASS, version )

	DEFINE CLASS SMIDI_QUEUE_CLASS INHERIT SMIDI_BASE_CLASS, SMIDI_QUEUE_CLASS:"_":STRIP(version)
	INITIALISATION
	ACTIONS

		"build_items"         IN LIBRARY SMIDI_LIB_QPUP       ,  { sets upload fields   }
		"upload_n_complete"   IN LIBRARY SMIDI_LIB_QPUP       ,  { User triger completes}
		"build_all_se_sr_mr"  IN LIBRARY SMIDI_LIB_QPUP       ,  { Build each/Alt-idi   }
		"build_a_se_sr_mr"    IN LIBRARY SMIDI_LIB_QPUP       ,  { Upload the Results   }
		"altidi_2_qmidi"      IN LIBRARY SMIDI_LIB_QPUP       ,  { call qm-idi via alt  }

		"build_a_mr"          IN LIBRARY SMIDI_LIB_UPLOAD_LIB ,  { MR type of upload    }
		"build_a_sr"          IN LIBRARY SMIDI_LIB_UPLOAD_LIB ,  { MR type of upload    }
		"build_a_se"          IN LIBRARY SMIDI_LIB_UPLOAD_LIB ,  { MR type of upload    }

		"errors_update_Q"     IN LIBRARY SMIDI_UPLOAD_USER_LIB, { Check errs/delete Q  }
		"change_before_send"  IN LIBRARY SMIDI_UPLOAD_USER_LIB  { change during upload }

	END CLASS

	{ ------------------------------------------------------------------------------------ }
	{ Queue item is only used by the triggers that write a new record to upload queue      }
	{ ------------------------------------------------------------------------------------ }

	smidi_lib_SAP_structure_class( SMIDI_QUEUE_ITEM_CLASS, version )

	DEFINE CLASS SMIDI_QUEUE_ITEM_CLASS INHERIT SMIDI_QUEUE_ITEM_CLASS:"_":STRIP(version)
	INITIALISATION
	ACTIONS

		"change_before_queue" IN LIBRARY SMIDI_UPLOAD_USER_LIB

	END CLASS

ENDROUTINE { define_smidi_queue_class }


{ ---------------------------------------------------------------------------- }
{                                                                              }
{                                                                              }
{           INITIALISATION ROUTINES FOR SMIDI UPLOAD CLASSES                   }
{                                                                              }
{                                                                              }
{ ---------------------------------------------------------------------------- }

ROUTINE smidi_que2_class_initialisation  ( self )

	ARRAY self.items
	ARRAY self.se_array
	ARRAY self.mr_array
	ARRAY self.sr_array
	ARRAY self.errors

	self.mr_count           = 0
	self.se_count           = 0
	self.sr_count           = 0
	self.sap_string         = ""
	self.sap_result_conf_no = ""
	self.smidi_lot          = ""
	self.smidi_op_no        = ""
	self.smidi_phys_samp    = "000000"
	self.outcome            = FALSE
	self.do_unit_convert    = FALSE
	self.current_count      = 0
	self.maximum_entries    = 1

	self.get_inherit_from_lib()

ENDROUTINE { smidi_queue_class_initialisation }

{******************************************************************************}

ROUTINE smidi_up_2_class_initialisation  ( self )

ENDROUTINE { smidi_up_2_class_initialisation (smidi_queue_item) }


{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{           U   P   L  O  A  D   ( S A P )    O  B  J  E  C  T  S              }
{                                                                              }
{                                                                              }
{ QAISR - single results                                                       }
{ QAIMR - multiple results                                                     }
{ QAISE - characteristics via selected set/codes                               }
{ QAIVE - usage decisions on lotsb                                             }
{ QMIFE - defects recording                                                    }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE smidi_qaisr_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QAISR", qmidi_object )

	DEFINE CLASS "QAISR" INHERIT SMIDI_BASE_CLASS, "QAISR_":STRIP(qmidi_object)
		INITIALISATION
	END CLASS

ENDROUTINE   { smidi_qaisr_init }

{******************************************************************************}

GLOBAL ROUTINE smidi_qaimr_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QAIMR", qmidi_object )

	DEFINE CLASS "QAIMR" INHERIT SMIDI_BASE_CLASS, "QAIMR_":STRIP(qmidi_object)
		INITIALISATION
	END CLASS

ENDROUTINE { smidi_qaimr_init }

{******************************************************************************}

GLOBAL ROUTINE smidi_qaise_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QAISE", qmidi_object )

	DEFINE CLASS "QAISE" INHERIT SMIDI_BASE_CLASS, "QAISE_":STRIP(qmidi_object)
		INITIALISATION
	END CLASS

ENDROUTINE { smidi_qaise_init }

{******************************************************************************}

GLOBAL ROUTINE smidi_qaive_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QAIVE", qmidi_object )

	DEFINE CLASS "QAIVE" INHERIT SMIDI_BASE_CLASS, "QAIVE_":STRIP(qmidi_object)
	INITIALISATION
	END CLASS

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE smidi_qmife_init ( VALUE qmidi_object )

	smidi_lib_SAP_structure_class( "QMIFE", qmidi_object )

	DEFINE CLASS "QMIFE"  INHERIT SMIDI_BASE_CLASS, "QMIFE_":STRIP(qmidi_object)
		INITIALISATION
	END CLASS

ENDROUTINE  { smidi_qmife_init }

{******************************************************************************}

ROUTINE qaisr_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qaisr_class_initialisation }

{******************************************************************************}

ROUTINE qaimr_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qaimr_class_initialisation }

{******************************************************************************}

ROUTINE qaise_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qaise_class_initialisation }

{******************************************************************************}

ROUTINE qaive_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qaive_class_initialisation }


{******************************************************************************}

ROUTINE qmife_class_initialisation (self)

	self.get_inherit_from_lib()

ENDROUTINE { qmife_class_initialisation }


{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{               D Y N A M I C   S T U C T U R E   C R E A T I O N              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE smidi_lib_SAP_structure_class ( VALUE data_type, qmidi_object ) 

	DECLARE items, property, class

	class = data_type : "_":STRIP(qmidi_object) 

	IF NOT class_defined ( class ) THEN

		class_add ( class )

		items = smidi_lib_SAP_structure_get_definition ( data_type, qmidi_object )

		items.set_first()

		WHILE ( items.current <> EMPTY ) DO 

			property = SELECT smidi_structure_items.internal_name IN OBJECT items.current
			class_add_property ( STRIP ( property ) )
	
			items.set_next()

		ENDWHILE

		class_activate()

	ELSE

		items = smidi_lib_SAP_structure_get_definition ( data_type, qmidi_object )

	ENDIF


	RETURN ( items )

ENDROUTINE { smidi_lib_SAP_structure_class }

{******************************************************************************}

ROUTINE smidi_lib_SAP_structure_get_definition ( data_type, qmidi_object ) 

	IF NOT ( user_cluster_exists ( SMIDI_CLUSTER_NAME ) ) THEN
		add_global_cluster ( SMIDI_CLUSTER_NAME )
	ENDIF

	IF NOT user_global_exists ( SMIDI_CLUSTER_NAME, data_type ) THEN
		smidi_lib_SAP_structure_add_definition ( data_type, qmidi_object )	
	ENDIF

	RETURN ( read_user_global ( SMIDI_CLUSTER_NAME, data_type )  )

ENDROUTINE { smidi_lib_SAP_structure_get_definition }

{******************************************************************************}

ROUTINE smidi_lib_SAP_structure_add_definition ( data_type, VALUE qmidi_object ) 

	DECLARE select_array, items, size
	ARRAY select_array

	array_select_add ( select_array, ARRAY_SELECT_EQ   , "IDENTITY"    , data_type              )
	array_select_add ( select_array, ARRAY_SELECT_EQ   , "SAP_VERSION" , qmidi_object           )
	array_select_add ( select_array, ARRAY_SELECT_ORDER, "SAP_ORDER"   , ARRAY_SELECT_ASCENDING )

	CREATE OBJECT "STD_OBJECT_DATABASE", items
		items.initialise ( "smidi_structure_items" )
		items.select     ( select_array    )
		items.add_index  ( "IDENTITY"      )
		items.add_index  ( "SAP_ORDER"     )

	add_user_global   ( SMIDI_CLUSTER_NAME, data_type        )
	user_global_write ( SMIDI_CLUSTER_NAME, data_type, items )

	size = items.size()

	RETURN ( size )      { this ain't used, but it sure is handy to see the number of recs read for object }

ENDROUTINE { smidi_lib_SAP_structure_add_definition }


{******************************************************************************}
{                                                                              }
{                                                                              }
{ All other libraries call this when converting SAP or SMP into the other      }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE smidi_lib_array_to_object (  VALUE data_type, msg_array, parent )

	DECLARE count, retval

	count = 1
	WHILE msg_array[ count ] <> empty DO

		msg_array[count] = smidi_lib_object_from_string ( data_type, msg_array[count], parent, count )
		count            = count + 1

	ENDWHILE

	IF count >= 1 THEN
		retval = SMIDI_NORMAL
	ELSE
		retval = SMIDI_NOLIB
	ENDIF

	return( retval )

ENDROUTINE   { smidi_lib_array_to_object }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_object_from_string ( VALUE data_type, VALUE msg_string, parent, VALUE count )

	DECLARE item, str_len, full_len, data, tmpString, items, sap_name, sap_descript, sap_property, class_name

	data       = EMPTY
	class_name = STRIP ( TOUPPER ( data_type ) )

	parent.status_message ( "smidi_lib_object_from_string ":data_type:"<":class_name:"> ":parent.qmidi_object, MSG_NONE )

	IF NOT ( class_defined ( class_name ) ) THEN

		IF ( VGL_VALIDATE_ROUTINE ( SMIDI_LIB_SAP, "smidi_":data_type:"_init" ) ) THEN

			CALL_ROUTINE "smidi_":data_type:"_init" USING parent.qmidi_object IN LIBRARY SMIDI_LIB_SAP

		ENDIF

	ENDIF   { if this is the very first time that this type of object is instantiated, then make it }

	{ ----------------------------------------------------------------- }
	{ Now that the dbase gave us properties, convert string into object }
	{ ----------------------------------------------------------------- }

	CREATE OBJECT data_type, data
		data.structure = data_type
		data.parent    = parent

	IF ( OBJECT_CHECK_PROPERTY ( data, "SAP_MESSAGE" ) ) THEN
		data.sap_message = msg_string
	ENDIF

	{ ---------------------------------------------------------------------- }
	{ Use this cached structure to build a object from a long message string }
	{ ---------------------------------------------------------------------- }

	items = smidi_lib_SAP_structure_class ( data_type, parent.qmidi_object )
	items.set_first()

	WHILE ( items.current <> EMPTY ) DO 

		item         = SELECT smidi_structure_items.internal_name IN OBJECT items.current
		sap_name     = SELECT smidi_structure_items.sap_name      IN OBJECT items.current
		sap_descript = SELECT smidi_structure_items.description   IN OBJECT items.current
		sap_property = SELECT smidi_structure_items.sap_property  IN OBJECT items.current
		str_len      = SELECT smidi_structure_items.sap_length    IN OBJECT items.current

		IF ( OBJECT_CHECK_PROPERTY ( data, item ) ) & ( sap_property ) THEN

			data.?item? = SUBSTRING ( msg_string, 1, str_len )

			tmpString = PAD ( STRIP ( item )         , "_", 20 ) : " | " :
				    PAD ( STRIP ( sap_name )     , "_", 10 ) : " | " :
				    PAD ( data.?item?            , "_", 80 ) : " | " :
				    PAD ( STRIP ( sap_descript ) , "_", 50 )
 
			parent.status_message ( tmpString, MSG_NONE )

		ELSEIF ( sap_property ) THEN

			parent.status_message ( "smidi_lib_object_from_string invalid SAP property ":item:" ":data_type, MSG_HIGH )

		ENDIF

		full_len   = STRINGLENGTH ( msg_string )
		msg_string = RIGHTSTRING ( msg_string, ( full_len - str_len ) )

		items.set_next()

	ENDWHILE


	{ ========================================================================================= }
	{ Once an object is created then call the user library so values can be set correctly       }
	{ ========================================================================================= }

	IF ( VGL_VALIDATE_ROUTINE ( SMIDI_USER_LIB, CREATE_OBJECT_ROUTINE ) ) THEN
		CALL_ROUTINE CREATE_OBJECT_ROUTINE IN LIBRARY SMIDI_USER_LIB USING data, parent
	ENDIF

	RETURN ( data )

ENDROUTINE  { smidi_lib_object_from_string }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_array_to_string( SAP_object, data_array )

	declare count

	count = 1
	WHILE data_array[ count ] <> empty DO

		data_array[ count ] = smidi_lib_object_to_string ( SAP_object[count])
		count               = count + 1

	ENDWHILE

ENDROUTINE   { smidi_lib_array_to_string }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_object_to_string ( SAP_object )

	DECLARE item, str_len, objects_len, msg_string, items, sap_property, data_type

	msg_string = ""
	data_type  = STRIP ( TOUPPER ( OBJECT_GET_CLASS_NAME ( SAP_object ) ) )
	items      = smidi_lib_SAP_structure_class ( data_type, SAP_object.qmidi_object )

	SAP_object.status_message ( "smidi_lib_object_to_string ":data_type:" version ":SAP_object.qmidi_object, MSG_NONE )

	items.set_first()

	WHILE ( items.current <> EMPTY ) DO 

		item         = SELECT smidi_structure_items.internal_name IN OBJECT items.current
		sap_property = SELECT smidi_structure_items.sap_property  IN OBJECT items.current
		str_len      = SELECT smidi_structure_items.sap_length    IN OBJECT items.current

		IF ( OBJECT_CHECK_PROPERTY ( SAP_object, item ) ) & ( sap_property ) THEN

			IF ( VARIABLE_IS_ASSIGNED ( SAP_object.?item? ) ) & ( SAP_object.?item? <> EMPTY ) THEN

				objects_len = STRINGLENGTH ( SAP_object.?item? )

				IF ( objects_len > str_len ) THEN
					msg_string = msg_string : LEFTSTRING ( SAP_object.?item?, str_len )
				ELSE
					msg_string = msg_string : PAD ( SAP_object.?item?, " ", str_len )
				ENDIF

				SAP_object.status_message ( "smidi_lib_object_to_string ":data_type:"->":item:" ":objects_len:" ":str_len:" ":msg_string, MSG_NONE )

			ELSE

				msg_string = msg_string : PAD ( "", " ", str_len )
				SAP_object.status_message ( "*** WARNING smidi_lib_object_to_string ":data_type:"->":item:" is empty or not assigned", MSG_10 )

			ENDIF

		ELSEIF ( sap_property ) THEN
	
			SAP_object.status_message ( "smidi_lib_object_to_string invalid item for object ":data_type:"->":item, MSG_LOW )

		ENDIF

		items.set_next()

	ENDWHILE

	RETURN ( msg_string )

ENDROUTINE  { smidi_lib_object_to_string }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{           SAP OBJECT ACTIONS THAT ARE USED THROUGHOUT SMIDI                  }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE qaivc_action_create_record( self )

        DECLARE found, status, rq_key, job_key, system

        status  = empty
        rq_key  = self.lot_no : self.op_no
        job_key = self.lot_no
        system  = smidi_lib_get_r3sys()

        found = SELECT smidi_request_header.request_key
                WHERE  smidi_system = system
                AND    request_key  = rq_key

        IF found = EMPTY THEN

                RESERVE ENTRY smidi_request_header, system : PAD (rq_key," ",30), status

                IF status = empty THEN

                        assign smidi_request_header.job_key      = job_key
                        assign smidi_request_header.mlp_id       = self.product_object.product_id
                        assign smidi_request_header.mlp_version  = self.product_object.product_version
			assign smidi_request_header.qmidi_object = self.qmidi_object
                        assign smidi_request_header.message      = self.sap_message

			IF self.qiwlr <> EMPTY THEN
				assign smidi_request_header.qiwlr = LEFTSTRING ( self.qiwlr.sap_message, 194 )
			ENDIF

			self.map_fields ( "SMIDI_REQUEST_HEADER" )

                        update smidi_request_header

		ELSE
			self.status_message ( "qaivc_action_create_record Error creating smidi_request_header ":system:rq_key:" ":status, MSG_HIGH )
		ENDIF

        ENDIF

        return( status = empty )

ENDROUTINE   { qaivc_action_create_record }

{******************************************************************************}

ROUTINE qaimv_action_create_record( self)

	DECLARE found, status, rq_key, rslt_key, samp_key, entry_code, srr_key, subsys,
		rq_len, rr_len, ss_len

	GET_FIELD_DETAILS smidi_request_record.request_key, "FIELD_SIZE", rq_len
	GET_FIELD_DETAILS smidi_request_record.result_key , "FIELD_SIZE", rr_len
	GET_FIELD_DETAILS smidi_request_record.sample_key , "FIELD_SIZE", ss_len

	status   = empty
	rq_key   = PAD ( self.lot_no : self.op_no, " ", rq_len )
	rslt_key = PAD ( self.result_number      , " ", rr_len )
	samp_key = PAD ( self.physical_sample_no , " ", ss_len )
	subsys   = smidi_lib_get_r3sys()

	found = select smidi_request_record.request_key
			where (smidi_system = subsys    )
			and   (request_key  = rq_key    )
			and   (result_key   = rslt_key  )

	IF found = empty THEN

		srr_key = subsys : rq_key : rslt_key : samp_key

		RESERVE ENTRY smidi_request_record, srr_key ,status

		IF status = empty THEN

			entry_code = PACKED_DECIMAL ( INCREMENT( "SMIDI_RQST", "ENTRY_CODE" ) )

			assign smidi_request_record.entry_code          = entry_code
			assign smidi_request_record.analysis_id         = self.analysis_id
			assign smidi_request_record.component_name      = self.component_name
			assign smidi_request_record.qmidi_object        = self.qmidi_object
			assign smidi_request_record.sap_code_group      = self.cat_1_sset_group
			assign smidi_request_record.sap_doc_required    = self.doc_required
			assign smidi_request_record.sap_need_subsamps   = self.need_subsamples
			assign smidi_request_record.sap_inspect_scope   = self.inspection_scope
			assign smidi_request_record.sap_result_type     = self.result_type
			assign smidi_request_record.sap_subsamp_valtype = self.subsamp_val_type
			assign smidi_request_record.sap_units           = self.char_unit
			assign smidi_request_record.smidi_lot           = self.lot_no
			assign smidi_request_record.sap_valuate_type    = self.valuation_type
			assign smidi_request_record.sap_subsys_valuates = self.subsys_valuates
			assign smidi_request_record.sap_serial_required = self.serial_no_required
			assign smidi_request_record.sap_places          = self.decimal_places
			assign smidi_request_record.message             = self.sap_message

			self.map_fields ( "SMIDI_REQUEST_RECORD" )

			update smidi_request_record

		ELSE
			self.status_message ( "qaimv_action_create_record Error creating smidi_request_record ":srr_key:" ":status, MSG_HIGH )
		ENDIF

	ENDIF

	return( status = empty )

ENDROUTINE    { qaimv_action_create_record }

{******************************************************************************}

ROUTINE qaimv_action_get_test_counts(self,rep_info)

	DECLARE count, subsamps, samp

	array rep_info

	subsamps = convert_r3_number( self.num_subsamples )
	IF subsamps = 0 THEN

		subsamps = 1

	ENDIF
	count = 1
	WHILE count <= subsamps DO

		rep_info[ count ] = 0
		count = count + 1

	ENDWHILE

	count = convert_r3_number( self.sample_size )
	WHILE count <> 0 DO

		samp = ( count MOD subsamps ) + 1
		rep_info[ samp ] = rep_info[ samp ] + 1
		count = count - 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE qaimv_action_get_result_type(self)

	DECLARE result_type

	IF index( LIMS_NUMERIC_TYPES, self.result_type ) <> 0 THEN                  {"ADGJMP"}

		result_type = "N"

	ELSEIF index( LIMS_OPTIONAL_TYPES, self.result_type ) <> 0 THEN             {"BEHKNQ"}

		result_type = "O"

	ELSEIF index( LIMS_DEFECT_OR_BOOLEAN_TYPES, self.result_type ) <> 0 THEN    {"CFILOR"}

		IF self.valuation_type = "B" THEN

			result_type = "N"

		ELSE

			result_type = "B"

		ENDIF
	ELSE

		result_type = LIMS_UNKNOWN_RESULT_TYPE

	ENDIF

	return( result_type )

ENDROUTINE

{******************************************************************************}

ROUTINE qaimv_action_get_upload_type(self)

	DECLARE upload_type

	IF index( SAP_SE_MR_UPLOAD_TYPES, self.result_type ) <> 0 THEN         {"ABCJKLMNO"}

		upload_type = "QAISE"

	ELSEIF index( SAP_SR_MR_UPLOAD_TYPES, self.result_type ) <> 0 THEN     {"DEFPQR"}

		upload_type = "QAISR"

	ELSEIF index( SAP_MR_UPLOAD_TYPES, self.result_type ) <> 0 THEN        {"GHI"}

		upload_type = "QAIMR"

	ELSE

		upload_type = error

	ENDIF

	return( upload_type )

ENDROUTINE


{******************************************************************************}
{                                                                              }
{                                                                              }
{                     SIGN_ON AS A USER TO THE SAP SYSTEM                      }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE smidi_lib_check_license
	
	DECLARE find_record

	find_record = check_license ( "SMIDI" )

	RETURN ( find_record = EMPTY )

ENDROUTINE { smidi_lib_check_license }

{******************************************************************************}

ROUTINE smidi_V2_action_login ( self, VALUE sys_id )

	DECLARE status

	self.status_mess_decode ( "SMIDI_DOWNLOAD_CONNECT", MSG_LOW, sys_id, EMPTY, EMPTY )

	status = smidi_lib_client_logon ( sys_id )

	IF status <> SMIDI_NORMAL THEN
		self.rfc_error ( "F", "LOGIN", status )
	ENDIF

	RETURN ( status = SMIDI_NORMAL )

ENDROUTINE { smidi_base_action_login }

{******************************************************************************}

ROUTINE smidi_V2_action_logout ( self )

	self.status_message ( GET_USER_MESSAGE ( "SMIDI_DOWNLOAD_DISCONNECT", 1 ), MSG_LOW )
	smidi_lib_client_logoff()

ENDROUTINE { smidi_base_action_logout }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_client_logon( VALUE r3_system )

	declare retval, host, service, protocol, login_info

	retval   = SMIDI_BADSYS
	r3sys_id = select smidi_system.identity
			where (identity = r3_system)
			and   (removeflag = FALSE)

	IF (r3sys_id <> empty) THEN

		host      = STRIP ( select smidi_system.smidi_host     )
		service   = STRIP ( select smidi_system.smidi_service  )
		subsys_id = select smidi_system.subsystem_id
		protocol  = STRIP ( select smidi_system.smidi_protocol )

		IF protocol = "LOCAL" THEN
			protocol = "TCP"
		ENDIF
	
		retval = r3_connect( host, service, protocol )

		IF retval = EMPTY THEN

			login_info = select smidi_system.r3_destination :
				     select smidi_system.r3_mode	     :
				     select smidi_system.r3_client	     :
				     select smidi_system.r3_user	     :
				     select smidi_system.r3_password    :
				     select smidi_system.r3_language    :
				     select smidi_system.r3_trace	     :
				     select smidi_system.r3_hostname    :
				     select smidi_system.r3_sysnr	     :
				     select smidi_system.r3_gwhost	     :
				     select smidi_system.r3_gwservice
	
			retval = r3_logon( login_info )

		ELSE

			retval = SMIDI_BADSYS

		ENDIF

	ELSE

		retval = SMIDI_BADSYS

	ENDIF

	return( retval )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_client_logoff

	r3_logoff()
	r3_release()
	subsys_id = "      "
	r3sys_id  = "          "

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_get_subsys

	return( subsys_id )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_get_r3sys

	return( r3sys_id )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_SET_r3sys ( VALUE r3_system )

	r3sys_id = select smidi_system.identity
			where (identity = r3_system)
			and   (removeflag = FALSE)

	IF (r3sys_id <> empty) THEN

		subsys_id = select smidi_system.subsystem_id

	ENDIF

	RETURN ( r3sys_id <> EMPTY )

ENDROUTINE  { smidi_lib_SET_r3sys }


{******************************************************************************}
{                                                                              }
{                                                                              }
{                       G E N E R A L      R O U T I N E S                     }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE flag_set(VALUE flag)

	return(flag = "X")

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE set_flag(VALUE bool_flag)

	DECLARE retval

	IF ( bool_flag = EMPTY ) THEN
		retval = " "
	ELSEIF bool_flag THEN
		retval = "X"

	ELSE

		retval = " "

	ENDIF

	return(retval)

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE convert_r3_date(VALUE indate, VALUE intime)

	declare outdate

	set date format "YYYYMZDZ H24MISS"
	outdate = indate : " " : intime
	outdate = date(outdate)
	restore date format
	return(outdate)

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE convert_r3_date_with_format(VALUE indate, VALUE intime, VALUE timeformat)

	declare outdate

	set date format "YYYYMZDZ H24MISS"
	outdate = indate : " " : intime
	outdate = date(outdate)
	restore date format

	IF NOT BLANK ( timeformat ) THEN
		set date format timeformat
		outdate = STRIP ( outdate )
		restore date format
	ENDIF

	return(outdate)

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE convert_vg_date(VALUE indate)

	declare outdate

	IF strip(indate) = strip(" ") THEN

		outdate = "        "

	ELSE

		indate = date(indate)
		set date format "YYYYMZDZ"
		outdate = strip(indate)
		restore date format

	ENDIF
	return(outdate)

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE convert_vg_time(VALUE intime)

	declare outtime

	IF strip(intime) = strip(" ") THEN

		outtime = "      "

	ELSE

		intime = date(intime)
		set date format "H24MISS"
		outtime = strip(intime)
		restore date format

	ENDIF
	return(outtime)

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE convert_r3_number(VALUE innum)

	declare outnum

	outnum = numeric(innum)
	return(outnum)

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE convert_vg_number(VALUE innum, VALUE numlen)

	declare outnum, oldformat

	oldformat = global("FORMAT_TEXT")
	set format "999999999999"
	outnum = rightstring(pad("0","0",numlen) : strip(innum),numlen)
	set format oldformat
	return(outnum)

ENDROUTINE

{ ---------------------------------------------------------------------------- }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{               C O N F I G U R A T I O N   I N T E R F A C E                  }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{ ---------------------------------------------------------------------------- }

GLOBAL ROUTINE smidi_lib_get_config ( VALUE system, VALUE query )

	IF ( NOT VARIABLE_IS_ASSIGNED ( config ) ) THEN
		smidi_lib_config_item ( "ALL", system, query )
	ENDIF

	return( config )

ENDROUTINE   { get the collection class CONFIG variable to return to caller }

{******************************************************************************}

ROUTINE smidi_V2_action_set_config ( self )

	self.config = smidi_lib_get_config ( self.smidi_server, self.smidi_query )

ENDROUTINE { smidi_base_action_set_config }

{******************************************************************************}

ROUTINE smidi_lib_config_item ( VALUE item, VALUE system, VALUE query )

	DECLARE reload
	reload = FALSE

	IF variable_is_assigned ( config ) THEN

		IF ( system <> EMPTY ) AND ( query <> EMPTY ) THEN
			reload = NOT (( config.server = system ) AND ( config.query = query ))
		ENDIF

	ELSE

		define_smidi_cnf_collection_class()
		reload = TRUE

	ENDIF

	{ ================================================================== }
	{ The load is done when the first config collection is defined or    }
	{ when the system/server is not empty (thus is set specific)         }
	{ ================================================================== }

	IF reload THEN

		CREATE OBJECT SMIDI_CNF_COLLECTION_CLASS, config
			config.query  = query
			config.server = system
			config.load_data()

	ENDIF

	RETURN ( config.get_item ( item ) )

ENDROUTINE { smidi_lib_get_config }

{******************************************************************************}

GLOBAL ROUTINE smidi_V2_action_get_item ( self, VALUE item )

	DECLARE val
	val = EMPTY

	IF  (OBJECT_CHECK_PROPERTY(self,"PARENT")) & (VARIABLE_IS_ASSIGNED(self.parent)) & 
		(TOUPPER(VARIABLE_GET_TYPE(self.parent))="OBJECT") THEN

		val = self.parent.get_item ( item )

	ELSEIF ( OBJECT_CHECK_PROPERTY ( self, "SMIDIQUERY" ) ) AND ( OBJECT_CHECK_PROPERTY ( self, "SMIDISERVER" ) ) 
	AND    ( VARIABLE_IS_ASSIGNED  ( self.smidi_query   ) ) AND ( VARIABLE_IS_ASSIGNED  ( self.smidi_server   ) ) THEN


		val = smidi_lib_config_item ( item, self.smidi_server, self.smidi_query )  { item, system, query set }


	ELSE

		val = smidi_lib_config_item ( item, EMPTY, EMPTY )                         { item, system/query=EMPTY }

	ENDIF

	RETURN ( val )

ENDROUTINE { smidi_base_action_get_item }

{******************************************************************************}

GLOBAL ROUTINE smidi_cnf_collection_action_load_data ( self )


	self.load_items ( "SMIDI_CONFIG_HEADER", EMPTY, EMPTY )

	IF self.server <> EMPTY THEN

		self.load_items ( "SMIDI_CONFIG_ITEM", "SERVER", self.server )

	ENDIF

	IF self.query <> EMPTY THEN

		self.load_items ( "SMIDI_CONFIG_ITEM", "QUERY", self.query )

	ENDIF

ENDROUTINE { smidi_cnf_collection_action_load_data }

{******************************************************************************}

ROUTINE smidi_cnf_collection_action_load_items (       self, 
                                                 VALUE table, 
                                                 VALUE field,
                                                 VALUE criteria )


	DECLARE item

	IF field = EMPTY THEN

		IF ( self.level_id = EMPTY               ) OR 
		   ( NOT valid_field ( table, "LEVEL_ID" ) ) THEN

			item  = SELECT 'table'.identity 
			        WHERE identity > ""
	
		ELSE

			item  = SELECT 'table'.identity 
			        WHERE level_id = self.level_id

		ENDIF

	ELSE

		IF ( self.level_id = EMPTY               ) OR 
		   ( NOT valid_field ( table, "LEVEL_ID" ) ) THEN

			item  = SELECT 'table'.identity 
			        WHERE  'field' = criteria
	
		ELSE

			item  = SELECT 'table'.identity 
			        WHERE  'field'  = criteria
			        AND    level_id = self.level_id

		ENDIF

	ENDIF

	WHILE item <> EMPTY DO

		self.add_config ( table )
		NEXT 'table'
		item = SELECT 'table'.identity

	ENDWHILE

ENDROUTINE { smidi_cnf_collection_action_load_items }

{******************************************************************************}

ROUTINE smidi_cnf_collection_action_add_config ( self, VALUE table )


	DECLARE identity, item

	identity = SELECT 'table'.identity
	
	IF self.get_item ( identity ) <> EMPTY THEN

		item = self.current

	ELSE { Create the Entry }

		CREATE OBJECT SMIDI_CNF_COLLECTED_CLASS, item
		item.identity  = identity
		item.query     = self.query
		item.server    = self.server
		self.add ( item )

	ENDIF

	item.value  =  SELECT 'table'.value

	object_copy_current_table ( item, table )
	object_set_current_table  ( item, table )

ENDROUTINE { smidi_cnf_collection_action_add_config }

{******************************************************************************}

ROUTINE smidi_cnf_collection_action_get_item ( self, VALUE item )


	DECLARE return_val
	return_val = EMPTY

	self.set_by_index ( "IDENTITY", item )

	IF self.current <> EMPTY THEN
		return_val = self.current.value 
	ENDIF

	RETURN ( return_val )

ENDROUTINE { smidi_cnf_collection_action_get_item }

{******************************************************************************}
{*                     C O N F I G     P R O M P T S                          *}
{******************************************************************************}

ROUTINE config_prompt_level ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON mlp_level

ENDROUTINE { config_prompt_level }

{******************************************************************************}

ROUTINE config_prompt_limit_calc ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON limit_calculation

ENDROUTINE { config_prompt_limit_calc }

{******************************************************************************}

ROUTINE config_prompt_phrase ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON phrase_header

ENDROUTINE { config_prompt_phrase }

{******************************************************************************}

ROUTINE config_prompt_syntax ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON syntax

ENDROUTINE { config_prompt_syntax }

{******************************************************************************}

ROUTINE config_prompt_analysis ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON analysis

ENDROUTINE { config_prompt_analysis }

{******************************************************************************}

ROUTINE config_prompt_job_template ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON job_template

ENDROUTINE { config_prompt_job_template }

{******************************************************************************}

ROUTINE config_prompt_sample_template ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON samp_tmpl_header

ENDROUTINE { config_prompt_sample_template }

{******************************************************************************}

ROUTINE config_prompt_default_mlp ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON mlp_header.identity

ENDROUTINE { config_prompt_default_mlp }

{******************************************************************************}

ROUTINE config_prompt_sample_status ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON valid_phrase_id.sampstat

ENDROUTINE { config_prompt_phrase }

{******************************************************************************}

ROUTINE config_prompt_component_list ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON versioned_c_l_header.comp_list

ENDROUTINE { config_prompt_component_list }

{******************************************************************************}

ROUTINE config_prompt_library ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON report

ENDROUTINE { config_prompt_library }

{******************************************************************************}

ROUTINE config_prompt_mapping ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON smidi_map_header

ENDROUTINE { config_prompt_mapping }

{******************************************************************************}

ROUTINE config_prompt_debug_level ( prompt_object )

	PROMPT OBJECT prompt_object BROWSE ON integer WITH ( minium = 1, maximum = 10 )

ENDROUTINE { config_prompt_debug_level }

{ ---------------------------------------------------------------------------- }
{                                                                              }
{                                                                              }
{                      M A P P I N G      A C T I O N S                        }
{                                                                              }
{                                                                              }
{ ---------------------------------------------------------------------------- }

GLOBAL ROUTINE smidi_lib_initialise_mapping ( map, parent )

	map.parent            = parent
	map.mapping_table     = SMIDI_MAPPING_TABLE
	map.mapping_field     = SMIDI_MAPPING_FIELD
	map.mapping_default   = SMIDI_MAPPING_DEFAULT
	map.mapping_info      = SMIDI_MAPPING_INFO
	map.mapping_left      = SMIDI_MAPPING_LEFT
	map.mapping_right     = SMIDI_MAPPING_RIGHT
	map.mapping_update    = SMIDI_MAPPING_UPDATE
	map.routine_field     = SMIDI_ROUTINE_FIELD
	map.library_field     = SMIDI_LIBRARY_FIELD

ENDROUTINE { smidi_lib_initialise_mapping }

{******************************************************************************}

ROUTINE gbi_mapping_action_value_from_default ( self, VALUE field_name )

	DECLARE return_val
	return_val = FALSE
        
	IF self.map_default <> EMPTY THEN

		return_val     = TRUE
		self.map_value = self.map_default
       		self.store_value ( field_name, self.map_default )

	ENDIF
                
	RETURN ( return_val )

ENDROUTINE { gbi_login_action_value_from_default }

{******************************************************************************}

ROUTINE gbi_mapping_action_value_from_routine ( self, VALUE field_name )

	DECLARE return_val

	return_val = FALSE
        
	IF ( NOT BLANK(self.map_library) ) AND ( VGL_VALIDATE_ROUTINE(self.map_library, self.map_routine) ) THEN

		CALL_ROUTINE self.map_routine IN LIBRARY self.map_library USING self RETURNING self.map_value

		IF ( self.map_value <> EMPTY ) THEN
        
			return_val = TRUE
			self.store_value ( field_name, self.map_value )

		ENDIF   { val has to return empty, but then to get the default you gotta have FALSE }

	ELSE

		self.status_message ( "Mapping invalid setup library/routine ":self.map_library:"/":self.map_routine, MSG_HIGH )

	ENDIF   { only map when you really have all to map }
        
	RETURN ( return_val )

ENDROUTINE { gbi_login_action_value_from_routine }

{******************************************************************************}

ROUTINE gbi_mapping_action_value_from_map ( self, VALUE field_name )


	DECLARE val, return_val

	val        = EMPTY
	return_val = FALSE

	IF ( self.mapping_routine <> EMPTY ) AND ( self.mapping_field = EMPTY ) THEN

		CALL_ROUTINE self.mapping_routine IN LIBRARY self.mapping_library
			USING self RETURNING self.map_property
        
	ENDIF

	{ ========================================================================== }
	{                                                                            }
	{ Hierarchy of objects searched does not use the MAPPING profile to actually }
	{ find the object (QAIVC, QAIMV, rather it just search the tree until the    }
	{ variable name is found and has a value that is not empty                   }
	{                                                                            }
	{ first look at    self->parent->master->                                    }
	{ then use SEARCH  master.master->master.parent->parent.master               }
	{                                                                            }
	{ ========================================================================== }


	IF NOT BLANK ( self.map_property ) THEN

		val = self.get_property ( self, self.map_property )

		IF val = EMPTY THEN

			val = self.get_property ( self.parent, self.map_property )

			IF val = EMPTY THEN
				val = self.get_property ( self.master, self.map_property )
			ENDIF

			IF val = EMPTY THEN
				val = self.search_property ( self, self.map_property )
			ENDIF

		ENDIF

		IF val = EMPTY THEN

			flash_message ( "Invalid map property ":self.map_property, FALSE )
			self.status_mess_decode ( "GBI_MAPPING_PROP", MSG_FULL, self.map_property, EMPTY, EMPTY )

		ENDIF
                
	ENDIF

	IF ( val <> EMPTY ) AND ( NOT BLANK ( val ) ) THEN

		{ ================================================================== }
		{ Apply any left/right or substrings based upon mapping profile      }
		{ ================================================================== }

		IF ( self.number_left > 0 ) AND ( self.number_right > 0 ) THEN

			self.status_message ( "gbi_mapping_action_value_from_map <":STRIP(val):"> [":self.number_left:"/":self.number_right:"]", MSG_LOW )
			val = SUBSTRING ( val, self.number_left, self.number_right )
	
		ELSEIF ( self.number_left > 0 ) THEN
	
			self.status_message ( "gbi_mapping_action_value_from_map <":STRIP(val):"> LEFT-> [":self.number_left:"]", MSG_LOW )
			val = LEFTSTRING ( val, self.number_left )

		ELSEIF ( self.number_right > 0 ) THEN

			self.status_message ( "gbi_mapping_action_value_from_map <":STRIP(val):"> RIGHT-> [":self.number_right:"]", MSG_LOW )
			val = RIGHTSTRING ( val, self.number_right )

		ENDIF

		self.store_value ( field_name, val )

		self.map_value = val
		return_val     = TRUE

	ENDIF

	RETURN ( return_val )

ENDROUTINE { gbi_mapping_action_value_from_map }

{******************************************************************************}

ROUTINE gbi_mapping_action_get_property ( self, object, VALUE map )

	DECLARE val
	val = EMPTY

	IF ( variable_is_assigned ( object ) ) AND ( object <> EMPTY ) THEN
        
		IF object_check_property ( object, map ) THEN

			val = object.?map?                    
        
		ENDIF

	ENDIF

	RETURN ( val )

ENDROUTINE { get_property }


{******************************************************************************}

ROUTINE gbi_mapping_action_search_property ( self, object, VALUE map )
{
	Been thru ------>>  self->self.parent->self.master  using get_property

	Now search ----->>      object.master.parent-> object.master.parent.master-> object.master.master->

	Then search ---->>	object.parent.master->

	And then search >>      object.parent.product->

	that about covers all the angles for the way the objects are made.....

}


	DECLARE val
	val = EMPTY

	{ ========================================================================== }
	{ object.master.parent-> object.master.parent.master->  object.master.master }
	{ ========================================================================== }

	IF  ( object_check_property ( object, "MASTER" ) )
	AND ( VARIABLE_IS_ASSIGNED  ( object.master )    ) 
	AND ( object.master <> EMPTY                     ) THEN

		IF  ( object_check_property ( object.master, "PARENT" ) ) 
		AND ( VARIABLE_IS_ASSIGNED  ( object.master.parent )    ) 
		AND ( object.master.parent <> EMPTY                     ) THEN

			IF object_check_property ( object.master.parent, map ) THEN

				val = object.master.parent.?map?                    

			ENDIF


			IF val = EMPTY THEN

				IF  ( object_check_property ( object.master.parent, "MASTER" ) )
				AND ( variable_is_assigned ( object.master.parent.master )     ) 
				AND ( object.master.parent.master <> EMPTY                     ) THEN

					IF object_check_property ( object.master.parent.master, map ) THEN
	
							val = object.master.parent.master.?map?                    

					ENDIF
				ENDIF

			ENDIF

		ENDIF  { object.master.parent }

		{ ===================================================== }
		{ did object.master.parent, now do object.master.master }
		{ ===================================================== }

		IF val = EMPTY THEN

			IF  ( object_check_property ( object.master, "MASTER" ) )
			AND ( VARIABLE_IS_ASSIGNED  ( object.master.master )    ) 
			AND ( object.master.master <> EMPTY                     ) THEN

       				IF object_check_property ( object.master.master, map ) THEN
	
					val = object.master.master.?map?                    

       				ENDIF
			ENDIF
		ENDIF


		{ ================================== }
		{ object.master.qaipp                }
		{ ================================== }

		IF val = EMPTY THEN

			IF  ( object_check_property ( object.master, "QAIPP" )  )
			AND ( VARIABLE_IS_ASSIGNED  ( object.master.qaipp )     ) 
			AND ( object.master.qaipp <> EMPTY                      ) THEN
	
				IF object_check_property ( object.master.qaipp, map ) THEN
		
					val = object.master.qaipp.?map?
	
				ENDIF
		
			ENDIF  { object.master.qaipp }

		ENDIF  {  val empty }

		{ ================================== }
		{ object.master.qiwlr                }
		{ ================================== }

		IF val = EMPTY THEN

			IF  ( object_check_property ( object.master, "QIWLR" )  )
			AND ( VARIABLE_IS_ASSIGNED  ( object.master.qiwlr )     ) 
			AND ( object.master.qiwlr <> EMPTY                      ) THEN
	
				IF object_check_property ( object.master.qiwlr, map ) THEN
		
					val = object.master.qiwlr.?map?
	
				ENDIF

			ENDIF  { object.master.qiwlr }

		ENDIF  {  val empty }


	ENDIF  { object.master is real and valid }


	{ ================================== }
	{ object.parent.XXXXXX               }
	{ ================================== }

	IF val = EMPTY THEN

		IF  ( object_check_property ( object, "PARENT" ) ) 
		AND ( VARIABLE_IS_ASSIGNED  ( object.parent )    )
		AND ( object.parent <> EMPTY                     ) THEN

			IF  ( object_check_property ( object.parent, "MASTER" )  )
			AND ( VARIABLE_IS_ASSIGNED  ( object.parent.master )     ) 
			AND ( object.parent.master <> EMPTY                      ) THEN
	
				IF object_check_property ( object.parent.master, map ) THEN
	
					val = object.parent.master.?map?

				ENDIF

			ENDIF  { object.parent.master }

			{ ================================== }
			{ object.parent.qaipp                }
			{ ================================== }

			IF val = EMPTY THEN

				IF  ( object_check_property ( object.parent, "QAIPP" )  )
				AND ( VARIABLE_IS_ASSIGNED  ( object.parent.qaipp )     ) 
				AND ( object.parent.qaipp <> EMPTY                      ) THEN
	
					IF object_check_property ( object.parent.qaipp, map ) THEN
		
						val = object.parent.qaipp.?map?
	
					ENDIF

				ENDIF  { object.parent.qaipp }

			ENDIF  {  val empty }

			{ ================================== }
			{ object.parent.qiwlr                }
			{ ================================== }

			IF val = EMPTY THEN

				IF  ( object_check_property ( object.parent, "QIWLR" )  )
				AND ( VARIABLE_IS_ASSIGNED  ( object.parent.qiwlr )     ) 
				AND ( object.parent.qiwlr <> EMPTY                      ) THEN
	
					IF object_check_property ( object.parent.qiwlr, map ) THEN
		
						val = object.parent.qiwlr.?map?
	
					ENDIF

				ENDIF  { object.parent.qiwlr }

			ENDIF  {  val empty }

			{ =========================== }
			{ object.parent.product_object}
			{ =========================== }

			IF ( val = EMPTY ) THEN

				IF  ( object_check_property ( object.parent, "PRODUCT_OBJECT" ) ) 
				AND ( VARIABLE_IS_ASSIGNED  ( object.parent.product_object    ) ) 
				AND ( object.parent.product_object <> EMPTY                     ) THEN

       					IF object_check_property ( object.parent.product_object, map ) THEN
	
						val = object.parent.product_object.?map?

					ENDIF

				ENDIF

			ENDIF  { object.parent.product_object }

		ENDIF   { object has parent, it is not empty and is assigned }

	ENDIF   { val empty from all other attempts }


	{ =================================== }
	{ think we searched enuf objects ?    }
	{ =================================== }

	RETURN ( val )


ENDROUTINE { search_property }

{******************************************************************************}

ROUTINE gbi_mapping_action_table_map ( self )

	DECLARE table, field

	table = self.mapping_table

	IF self.mapping_field <> EMPTY THEN

		field             = self.mapping_field
		self.map_property = SELECT 'table'.'field'

		IF self.mapping_routine <> EMPTY THEN

			CALL_ROUTINE self.mapping_routine IN LIBRARY self.mapping_library
                             USING self RETURNING self.map_property
        
		ENDIF

	ENDIF

	IF ( self.library_field <> EMPTY ) THEN
		self.map_library = SELECT 'table'.'self.library_field'
		self.map_routine = SELECT 'table'.'self.routine_field'                    
	ENDIF

	IF ( self.mapping_default <> EMPTY ) THEN
		self.map_default = SELECT 'table'.'self.mapping_default'
	ENDIF

	IF ( self.mapping_left <> EMPTY ) THEN
		self.number_left  = SELECT 'table'.'self.mapping_left'
	ENDIF

	IF ( self.mapping_right <> EMPTY ) THEN
		self.number_right = SELECT 'table'.'self.mapping_right' 
	ENDIF


	IF ( self.mapping_update <> EMPTY ) THEN
		self.map_update = SELECT 'table'.'self.mapping_update' 
	ENDIF



	self.map_lims_table = SELECT 'table'.TABLE_NAME
	self.map_lims_field = SELECT 'table'.FIELD_NAME


ENDROUTINE { gbi_mapping_action_table_map }

{******************************************************************************}

ROUTINE gbi_mapping_action_map ( self, VALUE field_name )

	DECLARE done
	done = FALSE
        
	IF ( self.map_property <> EMPTY ) AND ( NOT BLANK ( self.map_property )) THEN
		done = self.value_from_map ( field_name )
		self.status_message ( "gbi_mapping_action_map PROPERTY-> ":field_name:"=":self.map_property:" ":done, MSG_LOW )
	ENDIF


	IF NOT done THEN
		IF ( self.map_library <> EMPTY ) AND ( NOT BLANK ( self.map_library )) THEN
			done = self.value_from_routine ( field_name )                               
			self.status_message ( "gbi_mapping_action_map LIB/ROUT-> ":field_name:" done using ":self.map_library:"/":self.map_routine:" ":done, MSG_LOW )
		ENDIF
	ENDIF


	IF not done THEN
		IF ( self.map_default <> EMPTY ) AND ( NOT BLANK ( self.map_default )) THEN
			done = self.value_from_default ( field_name )                               
			self.status_message ( "gbi_mapping_action_map DEFAULT ":field_name:"=":self.map_default:" ":done, MSG_LOW )
		ENDIF
	ENDIF

ENDROUTINE { gbi_mapping_action_map }

{******************************************************************************}

ROUTINE gbi_mapping_action_status_message ( self, VALUE message, VALUE level )

	IF ( self.parent <> EMPTY ) AND ( object_check_action ( self.parent, "STATUS_MESSAGE" ) ) THEN

		self.parent.status_message ( message, level )

	ELSEIF ( self.master <> EMPTY ) AND ( object_check_action ( self.master, "STATUS_MESSAGE" ) ) THEN

		self.master.status_message ( message, level )

	ENDIF

ENDROUTINE { gbi_mapping_action_status_message } 

{******************************************************************************}

ROUTINE gbi_mapping_action_map_fields ( self, VALUE table )

	DECLARE map, key

	self.current_table = table

	IF self.mapping_table <> EMPTY THEN
                
		map = SELECT 'self.mapping_table'.field_name
                      WHERE mapping_profile = self.mapping_profile
                      AND   table_name      = table

		WHILE map <> EMPTY DO

			tmpString = "Mapping Profile [":STRIP(self.mapping_profile):"] ":STRIP(table):"->":
				STRIP(map):" ":STRIP(SELECT 'self.mapping_table'.SMP_NAME):"/":STRIP(SELECT 'self.mapping_table'.STRUCTURE):
				STRIP(SELECT 'self.mapping_table'.LIBRARY_NAME):"/":STRIP(SELECT 'self.mapping_table'.ROUTINE_NAME)

			IF ( VALID_FIELD ( table, map ) ) THEN

				GET_FIELD_DETAILS 'table'.'map' "KEY0_FIELD", key

				self.status_message ( tmpString, MSG_NONE )

				IF NOT key THEN
					self.table_map()
					self.map( map )
				ENDIF

			ELSE

				self.status_message ( ">>> *** INVALID TABLE/FIELD ":tmpString, MSG_FULL )

			ENDIF

			NEXT 'self.mapping_table'
			map = SELECT 'self.mapping_table'.field_name
                        
		ENDWHILE

	ENDIF

ENDROUTINE { gbi_mapping_action_map_fields }

{******************************************************************************}

ROUTINE gbi_mapping_action_store_value ( self, VALUE field_name, VALUE val )

	DECLARE key

	IF ( field_name <> EMPTY ) & ( VARIABLE_IS_ASSIGNED( self.current_table ) ) & ( self.current_table <> EMPTY ) THEN

		GET_FIELD_DETAILS 'self.current_table'.'field_name' "KEY0_FIELD", key

		IF NOT key THEN

			ASSIGN 'self.current_table'.'field_name' = val
			self.status_message ( "Saving_Table/Field/Value_> ":strip(self.current_table):"/":strip(field_name):"_>":STRIP(val):"<_", MSG_LOW )

		ENDIF

	ENDIF

ENDROUTINE { gbi_mapping_action_store_value }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{         BASE ACTIONS FOR THE MAPPING SHARED BY ALL SMIDI OBJECTS             }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE smidi_V2_action_get_map_header ( self, VALUE item )

	DECLARE val
	val = EMPTY

	IF  ( OBJECT_CHECK_PROPERTY ( self, "PARENT" ) ) AND
            ( VARIABLE_IS_ASSIGNED  ( self.parent    ) ) AND
	    ( self.parent <> EMPTY )                     THEN

		val = self.parent.get_map_header ( item )    { recursive get to the base object }

	ELSE

		val = SELECT SMIDI_MAP_HEADER.'item' WHERE MAPPING_PROFILE = self.mapping_profile

	ENDIF

	RETURN ( val )

ENDROUTINE { smidi_base_action_get_map_header }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_get_mapping ( VALUE profile, VALUE table, VALUE field, master, parent )

	DECLARE map, item, retval
	retval = EMPTY

	CREATE OBJECT "GBI_MAPPING", map
	smidi_lib_initialise_mapping ( map, parent )

	map.master = master

	item = SELECT 'map.mapping_table'.mapping_profile
	       WHERE mapping_profile = profile
	       AND   table_name      = table
	       AND   field_name      = field

	IF item <> EMPTY THEN

		map.table_map()
		map.map ( field )
		retval = map.map_value

	ENDIF

	RETURN ( retval )

ENDROUTINE { smidi_lib_get_mapping }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_get_map_field ( VALUE profile, VALUE lims_table, VALUE lims_field, VALUE lims_parameter )

	DECLARE retval

	retval = SELECT SMIDI_MAP_ITEM.'lims_parameter'
			WHERE MAPPING_PROFILE = profile
			AND   TABLE_NAME      = lims_table
			AND   FIELD_NAME      = lims_field

	IF retval = EMPTY THEN
		retval = FALSE
	ENDIF

	RETURN ( retval )

ENDROUTINE { smidi_lib_get_map_field }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{ RESULT/TEST ACTIONS - have unique needs since they are LIMS, not SAP errors  }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE smidi_result_upload_action_process_errors( self, save_errors )


	DECLARE ok

	smidi_lib_array_to_object( "QIERR", self.errors, self )
	ok = smidi_lib_output_errors ( self.errors, save_errors )

	return( ok )

ENDROUTINE

{******************************************************************************}

ROUTINE smidi_test_action_error_status ( self, VALUE level, VALUE utility, VALUE numb )

	DECLARE operation
	operation = self.master.master.parent
	operation.error_status ( level, utility, numb )

ENDROUTINE { smidi_test_action_error_status }


{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{             D O W N L O A D    E R R O R    R O U T I N E S                  }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE smidi_download_action_add_failures ( self )

	DECLARE message, count, err

	message = GET_USER_MESSAGE ( "SMIDI_DOWNLOAD_TRANS_FAIL", 1 ) 

	IF NOT TRANSACTION_IS_WRITE() THEN
		START WRITE TRANSACTION message
	ENDIF

	count = 1

	WHILE ( variable_is_assigned ( self.errors ) ) AND  ( self.errors[count] <> EMPTY ) DO

		err = self.errors[count]

		IF ( err.serious ) THEN

			IF ( err.lot_no = 0 ) THEN

				IF ( VARIABLE_IS_ASSIGNED ( self.last_lot ) ) THEN

					err.lot_no = self.last_lot

				ELSE
        
					message = "DOWNLOAD FAILURE, there is no way to recover "
					self.status_message ( message, MSG_HIGH )

				ENDIF

			ENDIF

			self.create_failure ( err.lot_no, err.message_no, err.message_text )
                                
		ENDIF

		count = count + 1       

	ENDWHILE

	COMMIT

ENDROUTINE { smidi_download_action_add_failures }

{******************************************************************************}

ROUTINE smidi_download_action_create_failure (       self , 
                                               VALUE lot  , 
                                               VALUE num  , 
                                               VALUE text )

	DECLARE found, status

	found = SELECT smidi_logfiles.smidi_lot
                FOR UPDATE
                WHERE smidi_logfile = self.parent.logfile

	IF ( found = EMPTY ) THEN
		RESERVE ENTRY smidi_logfiles, self.parent.service, status
	ENDIF

	ASSIGN smidi_logfiles.smidi_lot       = lot
	ASSIGN smidi_logfiles.a_error_message = text

	self.call_trigger ( lot, text, SML_CREATE_FAILURE_TRIGGER )

	UPDATE smidi_logfiles, status


ENDROUTINE { smidi_download_action_create_failure }

{******************************************************************************}

ROUTINE smidi_download_action_add_vgl_failures ( self )

	DECLARE lot, err_no, message, class_name

	message = GET_USER_MESSAGE ( "SMIDI_DOWNLOAD_TRANS_VGL", 1 ) 

	IF NOT TRANSACTION_IS_WRITE() THEN
		START WRITE TRANSACTION message
	ENDIF

	IF ( VARIABLE_IS_ASSIGNED ( self.operations ) ) & ( self.operations[1] <> EMPTY ) THEN

		lot        = SUBSTRING ( self.operations[1], 4, 12 )
		class_name = TOUPPER ( VARIABLE_GET_TYPE ( self.operations[1] ) )

		IF class_name = "OBJECT" THEN
			IF ( self.operations[1].error_msg <> EMPTY ) THEN
				err_no  = self.operations[1].error_no
				message = self.operations[1].error_msg
			ENDIF
		ELSE
			err_no  = 1
			message = "Invalid SAP response for QAILS"
		ENDIF

	ELSEIF ( self.worklist[1] <> EMPTY ) THEN

		lot     = SUBSTRING ( self.worklist[1], 10, 12 )
		err_no  = 2
		message = "SAP Locked record "

	ELSE

		lot     = self.qails.from_lot_no
		err_no  = 3
		message = "Unknown error condition, need some help "

	ENDIF

	self.create_failure ( lot, err_no, message )

	COMMIT

ENDROUTINE { smidi_download_action_add_vgl_failure }

{******************************************************************************}

ROUTINE smidi_download_action_download_error ( self, VALUE message )

	IF NUMTEXT ( message ) THEN
		message = smidi_lib_get_message ( message )
	ENDIF

	self.status_message ( message, MSG_HIGH )

ENDROUTINE { smidi_download_action_download_error }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{ smidi_lib_calls - ? this needs to be clarified to have one error system      }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE smidi_lib_get_message( VALUE error_no )

	declare msg, msg_id

	msg_id = "SMIDI_K_CONDITION_":convert_vg_number(error_no,3)
	msg    = get_user_message(msg_id,1)
	IF msg = error THEN

		msg_id = "SMIDI_K_CONDITION_":convert_vg_number(SMIDI_BADMSG,3)
		msg    = get_user_message(msg_id,1)

	ENDIF

	return( msg )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_output_errors ( errors, save_errors )

	DECLARE ok, count, err_cnt

	ok      = TRUE
	count   = 1
	err_cnt = SIZE_OF_ARRAY ( save_errors )

	WHILE errors[ count ] <> empty DO

		IF errors[count].is_serious() THEN

			ok                   = FALSE
			err_cnt              = err_cnt + 1
			save_errors[err_cnt] = errors[count]

			errors[count].report()     { <- just writes stuff to logfile }

		ELSE

			errors[count].status_message ( errors[count].message_text, MSG_10 )

		ENDIF

		count = count + 1

	ENDWHILE

	return( ok )

ENDROUTINE

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{ error_context handlers - this along with above needs to be clarified into 1  }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE error_context_add_data( VALUE data_id, VALUE data_value )

	error_context = error_context_get()
	error_context.add_data ( data_id, data_value )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE error_context_clear( VALUE data_id )

	error_context = error_context_get()
	error_context.clear ( data_id )

ENDROUTINE

{******************************************************************************}

ROUTINE message_prefix( VALUE severity, VALUE utility )

	DECLARE prefix

	IF severity = "S" THEN

		prefix = get_user_message("SMIDI_K_PREFIX_S",1)
		prefix = prefix : " - "

	ELSEIF severity = "I" THEN

		prefix = get_user_message("SMIDI_K_PREFIX_I",1)
		prefix = prefix : " - "

	ELSEIF severity = "W" THEN

		prefix = get_user_message("SMIDI_K_PREFIX_W",1)
		prefix = prefix : " " : utility : " - "

	ELSEIF severity = "E" THEN

		prefix = get_user_message("SMIDI_K_PREFIX_E",1)
		prefix = prefix : " " : utility : " - "

	ELSEIF severity = "F" THEN

		prefix = get_user_message("SMIDI_K_PREFIX_F",1)
		prefix = prefix : " " : utility : " - "

	ELSE

		prefix = "??? - "

	ENDIF

	return( prefix )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE message_out( VALUE severity, VALUE utility, VALUE message )

	error_status ( severity, utility, message )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE error_status( VALUE severity, VALUE utility, VALUE status )

	error_context = error_context_get()
	error_context.severity = severity

	IF NUMTEXT ( status ) THEN

		error_context.message_no   = status
		status = smidi_lib_get_message ( status )
		error_context.message_text = status : " (" : utility : ")"

	ELSE

		error_context.message_no   = "000"
		error_context.message_text = status : " (" : utility : ")"

	ENDIF	

	error_context.report()

ENDROUTINE

{******************************************************************************}

ROUTINE error_context_action_add_data ( self, VALUE data_id, VALUE data_value )

	IF object_check_property ( self, data_id ) THEN
		self.?data_id? = STRIP ( data_value )
	ELSE
		self.status_mess_decode ( "SMIDI_K_UNKNOWN", MSG_10, data_id:"/":data_value, EMPTY, EMPTY )
	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE error_context_action_clear ( self, VALUE data_id )

	IF data_id = "ALL" THEN

		self.add_data ( "JOB_HEADER"       , " " )
		self.add_data ( "SAMPLE"           , " " )
		self.add_data ( "TEST"             , " " )
		self.add_data ( "ANALYSIS"         , " " )
		self.add_data ( "REPLICATE"        , " " )
		self.add_data ( "COMPONENT"        , " " )
		self.add_data ( "LOT_NO"           , " " )
		self.add_data ( "OPERATION_NO"     , " " )
		self.add_data ( "CHARACTERISTIC_NO", " " )
		self.add_data ( "PHYSICAL_SAMPLE"  , " " )
		self.add_data ( "PARTIAL_SAMPLE"   , " " )

	ELSE

		self.add_data ( data_id, "" )
	
	ENDIF	

ENDROUTINE

{******************************************************************************}
{ ---------------------------------------------------------------------------- }
{                                                                              }
{                                                                              }
{  QIERR context is the error handling interface with SAP replies              }
{                                                                              }
{                                                                              }
{ ---------------------------------------------------------------------------- }
{******************************************************************************}

{******************************************************************************}

ROUTINE qierr_action_is_serious ( self )

	DECLARE ok_numbers

	ok_numbers   = self.get_item ( "ERROR_OK_NUMBERS"  )
	self.serious = ( INDEX ( ok_numbers, self.message_no ) = 0 )

	IF self.serious THEN

		self.serious = self.call_trigger ( ok_numbers, self.message_no, SML_SERIOUS_ERROR_TRIGGER )

	ENDIF

	RETURN ( self.serious )

ENDROUTINE   { qierr_action_is_serious }

{******************************************************************************}

ROUTINE qierr_action_report(self)
	
	DECLARE count
	ARRAY self.text_array

	count = 1
	self.text_array[count] = self.format_message()
	count = count + 1

	self.build_message ( self.text_array, 1 , "COUNTER"          , EMPTY, count ) 
	self.build_message ( self.text_array, 2 , "MESSAGE_NO"       , EMPTY, count ) 
	self.build_message ( self.text_array, 3 , "SEVERITY"         , EMPTY, count ) 
	self.build_message ( self.text_array, 4 , "LOT_NO"           , EMPTY, count ) 
	self.build_message ( self.text_array, 5 , "OP_SEQUENCE"      , EMPTY, count ) 
	self.build_message ( self.text_array, 6 , "OP_NO"            , EMPTY, count ) 
	self.build_message ( self.text_array, 7 , "NODE_NO"          , EMPTY, count )
	self.build_message ( self.text_array, 8 , "CHARACTERISTIC_NO", EMPTY, count ) 
	self.build_message ( self.text_array, 9 , "ENTRY_IS_SS"      , "ENTRY_IS_SS", count ) 
	self.build_message ( self.text_array, 10, "CAT_TYPE"         , "ENTRY_IS_SS", count ) 
	self.build_message ( self.text_array, 11, "CAT_PLANT"        , "ENTRY_IS_SS", count ) 
	self.build_message ( self.text_array, 12, "SELECTED_SET"     , EMPTY, count ) 
	self.build_message ( self.text_array, 13, "CODE_GROUP"       , EMPTY, count ) 
	self.build_message ( self.text_array, 14, "CODE"             , EMPTY, count ) 
	self.build_message ( self.text_array, 15, "RESULT_NUMBER"    , EMPTY, count ) 
	self.build_message ( self.text_array, 16, "PART_SAMPLE_NO"   , EMPTY, count ) 
	self.build_message ( self.text_array, 17, "TEST_COUNTER"     , EMPTY, count ) 
	self.build_message ( self.text_array, 18, "RECORD_TYPE"      , EMPTY, count ) 
	self.build_message ( self.text_array, 19, "MESSAGE_TEXT"     , EMPTY, count ) 
	self.build_message ( self.text_array, 20, "UTILITY"          , EMPTY, count ) 
	self.build_message ( self.text_array, 21, "JOB_HEADER"       , EMPTY, count ) 
	self.build_message ( self.text_array, 22, "SAMPLE"           , EMPTY, count ) 
	self.build_message ( self.text_array, 23, "TEST"             , EMPTY, count ) 
	self.build_message ( self.text_array, 24, "ANALYSIS"         , EMPTY, count ) 
	self.build_message ( self.text_array, 25, "REPLICATE"        , EMPTY, count ) 
	self.build_message ( self.text_array, 26, "COMPONENT"        , EMPTY, count ) 
	self.build_message ( self.text_array, 27, "PHYSICAL_SAMPLE"  , EMPTY, count ) 

	self.status_messages ( self.text_array, MSG_10 )

ENDROUTINE  { qierr_action_report }

{******************************************************************************}

ROUTINE qierr_action_build_message ( self, text_array, VALUE err_msg, VALUE property, VALUE check, count )

	DECLARE message

	IF ( check = EMPTY ) THEN 
		check = property 
	ENDIF

	IF ( variable_is_assigned ( self.?check? ) ) AND
	   ( self.?check? <> EMPTY                 ) AND 
	   ( NOT BLANK ( self.?check? )            ) THEN

		message              = GET_USER_MESSAGE ( "SMIDI_K_ERROR_QIERR", err_msg  )
		message              = message : "    " : STRIP ( self.?property? )
		text_array [ count ] = message
		count                = count + 1

	ENDIF

ENDROUTINE   { qierr_action_build_message }

{******************************************************************************}

ROUTINE qierr_action_format_message ( self )

	DECLARE message

	IF VARIABLE_IS_ASSIGNED ( self.counter ) THEN
		IF BLANK ( self.counter ) THEN 
			self.counter = "001"
		ENDIF
	ELSE
		self.counter = "001"
	ENDIF

	message = STRIP ( self.severity     ) : "-"    :
	          STRIP ( self.message_no   ) : " ("   :
	          STRIP ( self.counter      ) : ") > " : 
	          STRIP ( self.message_text ) : " ("   :
		    STRIP ( self.lot_no )       : ")"

	RETURN ( message )

ENDROUTINE

{******************************************************************************}

ROUTINE qierr_action_add_data ( self, VALUE data_id, VALUE data_value )

	IF object_check_property ( self, data_id ) THEN
		self.?data_id? = STRIP ( data_value )
	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE qierr_action_clear ( self, VALUE data_id )

	IF data_id = "ALL" THEN

		self.add_data ( "JOB_HEADER"       , " " )
		self.add_data ( "SAMPLE"           , " " )
		self.add_data ( "TEST"             , " " )
		self.add_data ( "ANALYSIS"         , " " )
		self.add_data ( "REPLICATE"        , " " )
		self.add_data ( "COMPONENT"        , " " )
		self.add_data ( "LOT_NO"           , " " )
		self.add_data ( "OP_NO"            , " " )
		self.add_data ( "CHARACTERISTIC_NO", " " )
		self.add_data ( "PHYSICAL_SAMPLE"  , " " )
		self.add_data ( "PART_SAMPLE_NO"   , " " )

	ELSE

		self.add_data ( data_id, "" )
	
	ENDIF	

ENDROUTINE

{******************************************************************************}
{ ---------------------------------------------------------------------------- }
{                                                                              }
{                                                                              }
{  Routines that perform the logfile output via the BASE_OBJECT actions        }
{  note that this includes the logfile as well as the base error handling      }
{                                                                              }
{                                                                              }
{ ---------------------------------------------------------------------------- }
{******************************************************************************}

ROUTINE smidi_V2_action_status_message ( self, VALUE message, VALUE msg_level )

	DECLARE status

	IF self.status_logging THEN

		IF ( msg_level >= MSG_HIGH ) | ( msg_level >= self.status_debug_mode )

			SET DATE FORMAT "H24:MI:SS"
			message = STRIP(msg_level) : " | " : STRIP ( NOW ) : " | " : STRIP(message)
			RESTORE DATE FORMAT
			FILE WRITE self.status_filename, message, status

			IF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN
				window_set_status ( message )
			ENDIF
		ENDIF

	ENDIF

ENDROUTINE { smidi_base_action_status_message }

{*****************************************************************************}

ROUTINE smidi_V2_action_status_messages ( self, messages, VALUE msg_level )

	DECLARE count, message

	IF self.status_logging THEN

		count = 1
		WHILE messages[count] <> EMPTY DO
			message = " >> " : messages [ count ]
			self.status_message ( message, msg_level )
			count = count + 1
		ENDWHILE

	ENDIF

ENDROUTINE { smidi_base_action_status_messages }

{*****************************************************************************}

ROUTINE smidi_V2_action_status_mess_decode ( self, VALUE find_message, VALUE msg_level, 
						     VALUE param       , VALUE prefix   , VALUE suffix )

	DECLARE message

	IF self.status_logging THEN
		IF self.status_filter ( msg_level ) THEN

			message_fetch ( find_message, message )
			message_add_parameter ( message, param )
			message = message_get_text ( message, 1 )
			self.status_message ( message, msg_level )

		ENDIF
	ENDIF

ENDROUTINE { smidi_base_action_status_messages }

{******************************************************************************}

ROUTINE smidi_V2_action_status_filter ( self, VALUE msg_level )

	IF ( msg_level >= MSG_10 ) THEN
		retval = TRUE
	ELSE
		retval = ( msg_level >= self.status_debug_mode )
	ENDIF

	RETURN ( retval )

ENDROUTINE { smidi_Base_action_status_filter }

{******************************************************************************}

ROUTINE smidi_V2_action_error_status ( self, VALUE severity, VALUE utility, VALUE message )

	self.error_msg = smidi_lib_get_message ( message )
	self.error_num = message
	error_status ( severity, utility, message )

ENDROUTINE

{******************************************************************************}

ROUTINE smidi_V2_action_rfc_error ( self,  VALUE severity, VALUE utility, VALUE status )

{
*	Outputs error messages generated by Remote Function Calls.
*
*	1) A message supplied by the VGL utility
*	2) An exception reported by the RFC or the system(s) invoking it
*	3) An error message reported by the RFC
*
*******************************************************************************}

	DECLARE messages, count, errkey, errsts, errmsg, errint, retval, exception

	ARRAY messages
	exception          = ""
	count              = 1	
	messages [ count ] = message_prefix(severity,utility):" ":smidi_lib_get_message ( status )
	count              = count + 1

	IF ( status = SMIDI_EXCEPTION ) OR ( status = SMIDI_SYS_EXCEPTION ) THEN

		r3_get_exception ( exception )

		messages [ count ] = GET_USER_MESSAGE ("SMIDI_K_EXCEPTION",1)
		count              = count + 1
		messages [ count ] = exception 
		count              = count + 1

	ENDIF	

	IF status <> SMIDI_CALL THEN

		retval = r3_get_error ( errkey, errsts, errmsg, errint )

		IF retval = SMIDI_NORMAL THEN
				
			messages [ count ] = errkey
			count = count + 1
			messages [ count ] = errsts
			count = count + 1
			messages [ count ] = errmsg
			count = count + 1
			messages [ count ] = errint
			count = count + 1
	
		ENDIF

		IF exception = "" THEN 

			exception = errkey : " " : errsts : " " : errmsg : " " : errint

		ENDIF

	ENDIF

	self.call_trigger ( messages, utility, SML_RFC_ERROR_TRIGGER )
	self.status_messages ( messages, MSG_10 )

	RETURN ( exception )

ENDROUTINE { smidi_base_action_rfc_error }

{******************************************************************************}

ROUTINE smidi_V2_action_add_failures ( self )

	DECLARE count, err

	IF NOT TRANSACTION_IS_WRITE() THEN
		START WRITE TRANSACTION ( GET_USER_MESSAGE ( "SMIDI_DOWNLOAD_TRANS_FAIL", 1 ) )
	ENDIF

	count = 1

	WHILE ( variable_is_assigned ( self.errors ) ) AND  ( self.errors[count] <> EMPTY ) DO

		err = self.errors[count]

		IF ( err.serious ) THEN

			IF ( err.lot_no = 0 ) THEN
				IF ( VARIABLE_IS_ASSIGNED ( self.last_lot ) ) THEN
					err.lot_no = self.last_lot
				ELSE
					self.status_message ( "DOWNLOAD FAILURE, there is no way to recover ", MSG_10 )
				ENDIF
			ENDIF

			self.create_failure ( err.lot_no, err.message_no, err.message_text )

		ENDIF

		count = count + 1       

	ENDWHILE

	COMMIT

ENDROUTINE { smidi_base_action_add_failures }

{******************************************************************************}

ROUTINE smidi_V2_action_add_vgl_failures ( self )

	DECLARE count, op, message, class_name, tmpString

	count   = 1
	message = GET_USER_MESSAGE ( "SMIDI_DOWNLOAD_TRANS_VGL", 1 ) 

	IF NOT TRANSACTION_IS_WRITE() THEN
		START WRITE TRANSACTION message
	ENDIF

	WHILE ( self.operations[count] <> EMPTY ) DO 

		op         = self.operations[count] 
		class_name = TOUPPER ( VARIABLE_GET_TYPE ( op ) )


		IF class_name = "OBJECT" THEN

			IF ( ( op.error_msg <> EMPTY ) AND ( self.call_trigger ( op, EMPTY, SML_ADD_VGL_FAILURE_TRIGGER ) ) ) THEN

				self.create_failure ( op.lot_no, op.error_num, op.error_msg )
	
			ENDIF

		ELSE

			tmpString = SUBSTRING ( op, 4, 12 )
			self.create_failure ( tmpString, "1", "SAP error" )

		ENDIF

		count = count + 1       

	ENDWHILE

	COMMIT

ENDROUTINE { smidi_base_action_add_vgl_failure }

{ ---------------------------------------------------------------------------- }
{                                                                              }
{                                                                              }
{              A R R A Y    C O N T A I N S    S L I C E                       }
{                                                                              }
{                                                                              }
{ ---------------------------------------------------------------------------- }

GLOBAL ROUTINE smidi_lib_array_contains_slice ( test_array, VALUE nested_id, index_found )

{       Return TRUE if nested_identity is (false if not) in the test_array      }


	DECLARE return_string                 { FALSE not in array, TRUE it is         }
	DECLARE count                         { count test_sched_array, check elements }

	return_string = FALSE
	count         = 0
	index_found   = 0

	IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

		WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

			count = count + 1

			IF ( test_array[count] = nested_id ) THEN

				return_string = TRUE
				index_found   = count
				count = SIZE_OF_ARRAY ( test_array )  { get outta while }

			ENDIF

		ENDWHILE

	ENDIF

	RETURN ( return_string )


ENDROUTINE   { end of array_contains_slice }

{******************************************************************************}

GLOBAL ROUTINE smidi_lib_array2_slice ( test_array, VALUE nested_id, index_found )

{       Return TRUE if nested_identity is (false if not) in the test_array      }


	DECLARE return_string                 { FALSE not in array, TRUE it is         }
	DECLARE count                         { count test_sched_array, check elements }

	return_string = FALSE
	count         = 0
	index_found   = 0

	IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

		WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

			count = count + 1

			IF ( test_array[count,1] = nested_id ) THEN

				return_string = TRUE
				index_found   = count
				count = SIZE_OF_ARRAY ( test_array )  { get outta while }

			ENDIF

		ENDWHILE

	ENDIF

	RETURN ( return_string )


ENDROUTINE   { end of array_contains_slice }


{******************************************************************************}
{ ---------------------------------------------------------------------------- }
{                                                                              }
{                                                                              }
{                   T R I G G E R S      I N T E R F A C E                     }
{                                                                              }
{                                                                              }
{ ---------------------------------------------------------------------------- }
{******************************************************************************}

ROUTINE smidi_V2_action_add_trigger (  self, VALUE rout, VALUE lib, VALUE pos )

	self.trigger [ ROUTINE_POS, pos ] = rout
	self.trigger [ LIBRARY_POS, pos ] = lib

ENDROUTINE  { add trigger }

{******************************************************************************}

ROUTINE smidi_V2_action_get_library ( self, VALUE pos )

	DECLARE lib

	lib = self.trigger [ LIBRARY_POS, pos ]

	IF lib = EMPTY THEN
		lib = SMIDI_DEFAULT_LIBRARY
	ENDIF

	RETURN ( lib )

ENDROUTINE { gbi_trigger_action_get_library }

{******************************************************************************}

ROUTINE smidi_V2_action_get_routine ( self, VALUE lib, VALUE pos )


	DECLARE rout

	rout = self.trigger [ ROUTINE_POS, pos ]

	IF rout = EMPTY THEN

		self.status_mess_decode ( "GBI_MAPPING_NONE", MSG_FULL, pos, EMPTY, EMPTY )

	ELSEIF NOT vgl_validate_routine ( lib, rout ) THEN

		self.status_mess_decode ( "GBI_MAPPING_TRIG", MSG_FULL, STRIP(lib):"/":STRIP(rout), EMPTY, EMPTY )
		rout = EMPTY

	ENDIF

	RETURN ( rout )

ENDROUTINE { smidi_base_action_get_routine }

{******************************************************************************}

ROUTINE smidi_V2_action_call_trigger ( self, object, VALUE val, VALUE pos )

	DECLARE retval, rout, lib

	{**********************************************************************}
	{ Call the Trigger Trigger!                                            }
	{**********************************************************************}
        
	lib = self.get_library ( GBI_MAPPING_TRIGGER_TRIGGER )

	IF lib <> EMPTY THEN

		rout = self.get_routine ( lib,  GBI_MAPPING_TRIGGER_TRIGGER )

		IF ( VGL_VALIDATE_ROUTINE ( lib, rout ) ) THEN

			CALLROUTINE rout IN LIBRARY lib USING self, object, val, pos RETURNING retval

		ENDIF

	ENDIF

	{**********************************************************************}
	{ Lets call the trigger routine.                                       }
	{**********************************************************************}

	lib  = self.get_library ( pos )

	IF lib <> EMPTY THEN
		rout = self.get_routine ( lib, pos )
	ENDIF

	IF ( lib <> EMPTY ) AND ( rout <> EMPTY ) THEN


		IF ( VGL_VALIDATE_ROUTINE ( lib, rout ) ) THEN

			IF ( object <> EMPTY ) THEN 

				IF ( val <> EMPTY ) THEN

 					CALLROUTINE rout IN LIBRARY lib
	                                    USING self, object, val RETURNING retval

				ELSE

					CALLROUTINE rout IN LIBRARY lib
        	                            USING self, object RETURNING retval

				ENDIF

			ELSE

				IF val <> EMPTY THEN

					CALLROUTINE rout IN LIBRARY lib
                	                    USING self, val RETURNING retval

				ELSE
	
					CALLROUTINE rout IN LIBRARY lib
                	                    USING self RETURNING retval

				ENDIF

			ENDIF   { object passed is empty or not }

		ELSE
	
			retval = EMPTY

		ENDIF  { validate routine/library }

	ENDIF  { library/routine not empty }

	IF NOT variable_is_assigned ( retval ) THEN
		retval = EMPTY
	ENDIF

	RETURN ( retval )

ENDROUTINE  { CALL TRIGGER }


{ **************************************************************************** }
{ **************************************************************************** }
{                                                                              }
{            SAP DOWNTIMES used by all signons to SAP                          }
{                                                                              }
{ **************************************************************************** }
{ **************************************************************************** }

GLOBAL ROUTINE smidi_lib_reset_start_time ( VALUE smidi_system )

{

        We need to check if this system's start time is within a scheduled 
        downtime for this SAP's system.  If so, then reset its "next" start
        time to the time when SAP will be "back up and running"
}


	DECLARE sap_downtimes     { the object dbase for this smidi system }
	DECLARE number_entries    { number of records in sap_downtimes     }
	DECLARE start             { build the start if needed              }
	DECLARE end               { build the end from downtimes           }
	DECLARE this_start        { sap_downtimes interval for start       }
	DECLARE this_end          { sap_downtimes interval for end         }
	DECLARE type              { is downtime a DATE or an INTERVAL      }
	DECLARE base_time         { NOW                                    }

	DECLARE downtime_select_array

	ARRAY downtime_select_array
	ARRAY_SELECT_ADD ( downtime_select_array, ARRAY_SELECT_EQ, "SMIDI_SYSTEM", smidi_system )


	base_time = NOW
	OBJECT_CREATE ( sap_downtimes, "STD_OBJECT_DATABASE" )
	sap_downtimes.initialise ( "SMIDI_SYSTEM_DOWNTIMES" )
	sap_downtimes.select     ( downtime_select_array )

	number_entries = sap_downtimes.size()   { number of downtimes for this server       }

	IF ( number_entries > 0 ) THEN

		sap_downtimes.set_first()

		WHILE sap_downtimes.current <> EMPTY DO

			type       = SELECT SMIDI_SYSTEM_DOWNTIMES.TYPE           IN OBJECT sap_downtimes.current
			this_start = SELECT SMIDI_SYSTEM_DOWNTIMES.START_DOWNTIME IN OBJECT sap_downtimes.current
			this_end   = SELECT SMIDI_SYSTEM_DOWNTIMES.END_DOWNTIME   IN OBJECT sap_downtimes.current

			IF type THEN     { T=Date, F=Interval }

				SET DATE FORMAT "DZ-MON-YYYY H24:MI:SS.CC"
				this_start = DATE ( STRIP(this_start) )
				this_end   = DATE ( STRIP(this_end)   )
				RESTORE DATE FORMAT

			ENDIF

			IF ( set_times ( type, start, end, base_time, this_start, this_end ) = base_time ) THEN
				sap_downtimes.set_next()
			ELSE
				sap_downtimes.current = EMPTY
			ENDIF

		ENDWHILE  { whilst checking each object dbase entry of downtimes }

	ENDIF   { if size is 0 then nothing in object database }

	RETURN ( base_time )

ENDROUTINE { reset_start_time }

{******************************************************************************}

ROUTINE set_times ( type, start, end, base_time, VALUE this_start, VALUE this_end )

        DECLARE this_day          { base_time (NOW) DY (MON,TUE) format    }
        DECLARE this_time         { base_time in time only format          }
        DECLARE day_pos           { find the " " in the interval           }
        DECLARE start_day         { day part of interval this_start        }
        DECLARE start_time        { time part of interval this_start       }
        DECLARE end_day           { day part of interval this_end          }
        DECLARE end_time          { time part of interval this_end         }
        DECLARE todays_date       { date only format                       }


	SET DATE FORMAT "DZ-MZ-YYYZ H24:MI:SS"
        start  = NOW - "9999 00:00"
        end    = NOW - "9999 00:00"               { "DZ-MZ-YYYZ H24:MI:SS" }
	RESTORE DATE FORMAT

        SET DATE FORMAT "DY" 
                this_day = STRIP ( NOW )
        RESTORE DATE FORMAT

        SET DATE FORMAT "H24:MI:SS"
                this_time = STRIP ( NOW )
        RESTORE DATE FORMAT

        SET DATE FORMAT "DZ-MON-YYYZ"
                todays_date = STRIP ( NOW )
        RESTORE DATE FORMAT

        day_pos    = INDEX ( STRIP ( this_start ), " " )
        start_day  = NUMERIC ( MIDSTRING ( STRIP ( this_start ), 1, day_pos ) )
        start_time = STRIP ( MIDSTRING ( STRIP ( this_start ), day_pos, STRINGLENGTH ( STRIP ( this_start ) ) ) )

        day_pos    = INDEX ( STRIP ( this_end ), " " )
        end_day    = NUMERIC ( MIDSTRING ( STRIP ( this_end ), 1, day_pos ) )
        end_time   = STRIP ( MIDSTRING ( STRIP ( this_end ), day_pos, STRINGLENGTH ( STRIP ( this_end ) ) ) )


	SET DATE FORMAT "DZ-MON-YYYY H24:MI:SS.CC"

	IF type THEN          { type = TRUE when an date, FALSE is a interval }

		start  = DATE(this_start)
		end    = DATE(this_end)

        ELSEIF ( start_day = 0 ) THEN

                start  = DATE ( STRIP ( todays_date : " " : start_time ) )
                end    = DATE ( STRIP ( todays_date : " " : end_time   ) )

        ELSEIF ( this_day_matches ( this_day, start_day, end_day ) )
        AND    ( ( this_time >= start_time ) | ( this_time <= end_time ) ) THEN

                start  = DATE ( todays_date : " " : start_time )
                end    = DATE ( todays_date : " " : end_time   )

        ENDIF   { this day is 0, 1\7 or higher }


	{ ================================================================================ }
	{ Make sure that start and end are valid dates, if not then give use passed params }
	{ ================================================================================ }


	IF ( is_date ( start ) ) THEN
		start = DATE ( start )
	ELSE
		start = this_start
	ENDIF

	IF ( is_date ( end ) ) THEN
		end = DATE ( end )
	ELSE
		end = this_end
	ENDIF

	{ ======================================================================= }
	{ if we need to change the base time then set it to the downtime end time }
	{ ======================================================================= }

	IF ( base_time >= start ) THEN
		IF ( base_time <= end ) THEN
			base_time = end
		ENDIF
	ENDIF  { if this moment is a scheduled downtime }


	RESTORE DATE FORMAT


        RETURN ( base_time )


ENDROUTINE { set times }

{******************************************************************************}

ROUTINE this_day_matches ( VALUE this_day, VALUE start_day, VALUE end_day )
        
        DECLARE jul_day, retval  { base_time julian day (###) format            }


        SET DATE FORMAT "DDZ"
        jul_day = STRIP ( NOW )
        RESTORE DATE FORMAT


        retval = FALSE       { assume this is not in window, unless it matches   }

        IF ( ( start_day <= 7 ) AND ( end_day <= 7 ) ) THEN    { weekly setting, days must match }

                IF     ( this_day = "MON" ) AND ( ( start_day  = 1 ) | ( end_day = 1 ) ) THEN
                        retval = TRUE
                ELSEIF ( this_day = "TUE" ) AND ( ( start_day  = 2 ) | ( end_day = 2 ) ) THEN
                        retval = TRUE
                ELSEIF ( this_day = "WED" ) AND ( ( start_day  = 3 ) | ( end_day = 3 ) ) THEN
                        retval = TRUE
                ELSEIF ( this_day = "THU" ) AND ( ( start_day  = 4 ) | ( end_day = 4 ) ) THEN
                        retval = TRUE
                ELSEIF ( this_day = "FRI" ) AND ( ( start_day  = 5 ) | ( end_day = 5 ) ) THEN
                        retval = TRUE
                ELSEIF ( this_day = "SAT" ) AND ( ( start_day  = 6 ) | ( end_day = 6 ) ) THEN
                        retval = TRUE
                ELSEIF ( this_day = "SUN" ) AND ( ( start_day  = 7 ) | ( end_day = 7 ) ) THEN
                        retval = TRUE
                ENDIF   { days 1-7 match }

        ELSEIF ( ( start_day <= 31 ) AND ( end_day <= 31 ) ) THEN      { monthly, e.g the 15th of each month }

		IF ( ( this_day >= start_day ) AND ( this_day <= end_day ) ) THEN
			retval = TRUE
		ENDIF

        ELSEIF ( start_day > 7 ) OR ( end_day > 7 ) THEN     { annual setting ( Christmas day etc ) }

                IF ( ( jul_day >= start_day ) AND ( jul_day <= end_day ) AND ( start_day < end_day ) )
                OR ( ( start_day > end_day ) AND ( jul_day > start_day ) ) THEN
                        retval = TRUE
                ENDIF

        ENDIF   { which day is it ?, first part is weekly, monthly, last annual }

        RETURN ( retval )

ENDROUTINE  { this_day_matches }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{  GLOBAL SSE routines - spreadsheets called from LTE's for each SM-IDI table  }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}
GLOBAL ROUTINE LTE_spreadsheet ( VALUE the_table, VALUE key_search_field )

	DECLARE spreadsheet

	create_the_spreadsheet ( the_table, key_search_field, spreadsheet, EMPTY, TRUE )
	spreadsheet.template_report = GLOBAL ( "CURRENT_LIBRARY" )
	spreadsheet.do_work()

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE LTE_sse_with_id ( VALUE the_table, VALUE key_search_field, VALUE key_id, VALUE mode )

	DECLARE spreadsheet

	create_the_spreadsheet ( the_table, key_search_field, spreadsheet, key_id, mode )
	spreadsheet.template_report = GLOBAL ( "CURRENT_LIBRARY" )
	spreadsheet.do_work()

ENDROUTINE

{******************************************************************************}

ROUTINE create_the_spreadsheet  ( VALUE the_table, VALUE key_search_field, spreadsheet, VALUE key_id, VALUE mode )

	spreadsheet_create ( spreadsheet )

	build_spreadsheet_from_table ( the_table, spreadsheet )

	spreadsheet.table_id = the_table

	spreadsheet.select_array[ 1, 1 ] = ARRAY_SELECT_LIKE
	spreadsheet.select_array[ 1, 2 ] = key_search_field

	IF key_id = EMPTY THEN
		spreadsheet.select_array[ 1, 3 ] = "%"
	ELSE
		spreadsheet.select_array[ 1, 3 ] = key_id
	ENDIF

	spreadsheet.lock_records          = mode

	spreadsheet.use_filter_routine    = FALSE
	spreadsheet.display_search_window = FALSE
	spreadsheet.allow_insert          = FALSE
	spreadsheet.insert_mandatory_only = FALSE
	spreadsheet.reprompt_for_criteria = GLOBAL ( "LABTABLE_MODE" )

	spreadsheet.edit_criteria         = TRUE
	spreadsheet.edit_ordering         = TRUE
	spreadsheet.view_mandatory        = TRUE
	spreadsheet.separator_lines       = TRUE

	spreadsheet.record_report         = EMPTY
	spreadsheet.record_routine        = EMPTY
	spreadsheet.global_status_change  = EMPTY
	spreadsheet.num_fixed_left        = 1

	spreadsheet.search_help           = "SSE_SEARCH_HELP"
	spreadsheet.spread_help           = "SSE_SPREAD_HELP"
	spreadsheet.select_help           = "SSE_SELECT_HELP"
	spreadsheet.insert_help           = "SSE_INSERT_HELP"
	spreadsheet.searching_txt         = GET_USER_MESSAGE("SSE_SEARCHING_TXT",1)
	spreadsheet.matches_found_txt     = GET_USER_MESSAGE("SSE_MATCHES_FOUND_TXT",1)
	spreadsheet.header_txt            = THE_TABLE
	spreadsheet.footer_txt            = GET_USER_MESSAGE("SSE_FOOTER_TXT" ,1)
	spreadsheet.do_txt                = GET_USER_MESSAGE("SSE_SUCCESS_TXT" ,1)
	spreadsheet.quit_txt              = GET_USER_MESSAGE("SSE_ABORT_TXT" ,1)
	spreadsheet.record_routine_txt    = GET_USER_MESSAGE(  "SSE_SELECT_PRESSED",2 )
	spreadsheet.propagate_txt         = GET_USER_MESSAGE( "SSE_SELECT_PRESSED",3 )
	spreadsheet.display_select_txt    = GET_USER_MESSAGE(  "SSE_SELECT_PRESSED",5 )
	spreadsheet.header_select_txt_id  = "SSE_VIEW_SELECT"
	spreadsheet.no_array_txt_id       = "SSE_NO_VIEW_SELECT"
	spreadsheet.insert_header_txt     = GET_USER_MESSAGE  ("SSE_INSERT_HEADER_TXT" ,1)
	spreadsheet.insert_footer_txt     = GET_USER_MESSAGE  ("SSE_INSERT_FOOTER_TXT" ,1)

ENDROUTINE  { create_the_spreadsheet }

{  ******************************************************************************  }

ROUTINE build_spreadsheet_from_table ( the_table, spreadsheet )

	DECLARE removeflag_field	,
		modified_on_field	,
		modified_by_field	,
		version_field		,
		is_key0			,
		a_field			,
		message_prompt		,
		field_array		,
		lte_count		,
		count			,
		display_format		,
		field_size

	{ --------------------------------------------------------------------- }
	{ Various internal fields that are not displayed/edited in the LTE      }
	{ --------------------------------------------------------------------- }

	GET_TABLE_DETAILS 'the_table', "REMOVE_FIELD"     , removeflag_field	
	GET_TABLE_DETAILS 'the_table', "MODIFIED_ON_FIELD", modified_on_field	
	GET_TABLE_DETAILS 'the_table', "MODIFIED_BY_FIELD", modified_by_field	
	GET_TABLE_DETAILS 'the_table' ,"VERSION_FIELD"    , version_field

	GET_FIELD_NAMES ( the_table, field_array )

	{ --------------------------------------------------------------------- }
	{ Go through all the fields on this table and paste on the LTE          }
	{ --------------------------------------------------------------------- }

	lte_count = 0
	count     = 1

	WHILE ( count <= SIZE_OF_ARRAY ( field_array ) ) DO

		IF NOT field_array[count,2] THEN

			a_field = field_array[count,1]

			GET_FIELD_DETAILS 'the_table'.'a_field', "PROMPT_DESCRIPTION", message_prompt
			GET_FIELD_DETAILS 'the_table'.'a_field', "KEY0_FIELD"        , is_key0
			GET_FIELD_DETAILS 'the_table'.'a_field', "FIELD_SIZE"        , field_size

			IF field_size > MAX_WIDTH THEN
				field_size = MAX_WIDTH
			ENDIF

			IF ( a_field = modified_on_field ) OR ( a_field = modified_by_field )

			ELSE

				IF ( is_key0 ) | ( a_field = version_field ) THEN
					display_format = "DISPLAY"
				ELSE
					display_format = "FORMAT"
				ENDIF

				lte_count                                                     = lte_count + 1
				spreadsheet.prompt_details [ lte_count, MESSAGE_POSITION    ] = message_prompt
				spreadsheet.prompt_details [ lte_count, TYPE_POSITION       ] = display_format
				spreadsheet.prompt_details [ lte_count, TABLE_NAME_POSITION ] = the_table
				spreadsheet.prompt_details [ lte_count, FIELD_NAME_POSITION ] = a_field
				spreadsheet.prompt_details [ lte_count, COLUMN_SIZE_POSITION] = field_size

			ENDIF  { don't get any linked to fields in this LTE }

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE  {	build_spreadsheet_from_table ( the_table ) }

{  ******************************************************************************  }
ROUTINE filter_routine ( block_row_id )
	RETURN ( TRUE )
ENDROUTINE

{  ******************************************************************************  }
ROUTINE record_sort ( block_row_id, block_row_pointers )
ENDROUTINE

{  ******************************************************************************  }
ROUTINE record_update ( block_row_id )
ENDROUTINE

{  ******************************************************************************  }
ROUTINE spreadsheet_saved ( block_row_id, select_array, mandatory_array )
ENDROUTINE


{ ============================================================================= }
{ This routine is called for any field that must check if there is approval     }
{ ============================================================================= }

ROUTINE approval_required ( col, line, disp, is_disp, crow, grid )

	DECLARE curr_field, curr_val, approved_choices, this_rec, count, check_table

	curr_field = STRIP ( grid.parent_prompt.template_fields[ crow, 1 ] )

	IF curr_field = "WORK_PROFILE" THEN
		curr_val = SELECT SAMPLE.PRODUCT
	ELSE
		curr_val = SELECT SAMPLE.'curr_field'
	ENDIF


	IF NOT is_disp THEN
	
		ARRAY approved_choices

		IF curr_field = "WORK_PROFILE" THEN
			check_table = "MLP_HEADER"
		ELSE
			check_table = curr_field
		ENDIF

		{ ================ Go find all the approved records for this table ========  }

		IF ( valid_field ( check_table, "APPROVAL_STATUS" ) ) THEN

			count    = 0
			this_rec = SELECT 'check_table'.identity WHERE APPROVAL_STATUS = "Authorised"

			WHILE this_rec <> EMPTY DO

				count                     = count + 1
				approved_choices[count,1] = this_rec
				approved_choices[count,2] = this_rec

				NEXT 'check_table'
				this_rec = SELECT 'check_table'.identity

			ENDWHILE

		ENDIF  { valid field on this table for APPROVAL_STATUS }

		{ ========================================================================================== }
		{ Got only one choice display it, more than one prompt, none, then you got serious problems  }
		{ ========================================================================================== }

		IF  ( SIZE_OF_ARRAY ( approved_choices ) = 1 ) THEN

			currval = approved_choices[1,1]
			PROMPT FOR currval AT col, line IN WINDOW disp WITH ( display_only=TRUE, value=currval )

		ELSEIF ( SIZE_OF_ARRAY ( approved_choices ) > 1 ) THEN

			PROMPT FOR currval AT col, line IN WINDOW disp CHOOSE OUT_OF approved_choices

		ELSE

			confirm_with_text ( "There are no approved items for you to choose from " )
			EXIT

		ENDIF

		{ ============  Special whenever we have a work profile ====================== }

		IF curr_field <> "WORK_PROFILE" THEN
			ASSIGN SAMPLE.'curr_field' = currval
		ELSE
			ASSIGN SAMPLE.PRODUCT       = currval
			ASSIGN SAMPLE.TEST_SCHEDULE = currval
		ENDIF

	ELSE

		DISPLAY currval AT col, line IN WINDOW disp

	ENDIF

ENDROUTINE  { approval_required }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{  GLOBAL sample login triggers - $mt_fields setup of lib/rout                 }
{  1.  any field that you wish to have approval phrase selection               }
{  2.  SMIDI_OPERATION - set the operation selection for SAP point creation    }
{  3.  SMIDI_PHYS_SAMP - set the physical sample for SAP point creation        }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

{ ============================================================================= }
{ This routine is called via the LOGIN TEMPLATE routine/action                  }
{ and is used whenever a sample login is needed to make a new inspection point  }
{ ============================================================================= }

ROUTINE smidi_op_no_choices ( VALUE col, VALUE line, disp, VALUE is_disp ) { , VALUE crow, grid ) }

	DECLARE this_lot, op_choices, count, this_op, opchoice, opprev

	ARRAY op_choices

	count    = 0
	opprev   = SELECT SAMPLE.SMIDI_OPERATION
	this_lot = SELECT SAMPLE.SMIDI_LOT

	IF NOT is_disp THEN

		IF this_lot <> EMPTY THEN

			this_op = SELECT SMIDI_POINTS_QUERY.FROM_IP_OP_NO WHERE FROM_IP_LOT = this_lot

			WHILE this_op <> EMPTY DO

				count               = count + 1
				op_choices[count,1] = this_op
				op_choices[count,2] = this_op

				NEXT SMIDI_POINTS_QUERY
				this_op = SELECT SMIDI_POINTS_QUERY.FROM_IP_OP_NO

			ENDWHILE

		ENDIF

		{ ========================================================================================== }
		{ Got only one choice display it, more than one prompt, none, then you got serious problems  }
		{ ========================================================================================== }

		IF  ( SIZE_OF_ARRAY ( op_choices ) = 1 ) THEN

			PROMPT FOR opchoice AT col, line IN WINDOW disp WITH ( display_only = TRUE, value = opchoices[1,1] )
			opchoice = op_choices[1,1]
			ASSIGN SAMPLE.SMIDI_OPERATION = opchoice

		ELSEIF ( SIZE_OF_ARRAY ( op_choices ) > 1 ) THEN

			PROMPT FOR opchoice AT col, line IN WINDOW disp CHOOSE OUT_OF op_choices
			ASSIGN SAMPLE.SMIDI_OPERATION = opchoice

		ELSEIF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN

			IF ( confirm_with_text ( "Use the default for the operation (0010) ? " ) ) THEN
				opprev = "0010"
			ELSE
				opprev = " "
			ENDIF

			ASSIGN SAMPLE.SMIDI_OPERATION = opprev
			DISPLAY opprev AT col, line IN WINDOW disp

		ELSE

			DISPLAY opprev AT col, line IN WINDOW disp

		ENDIF

		SET GLOBAL "LASTKEY" TO "RETURN"

	ELSE

		DISPLAY opprev AT col, line IN WINDOW disp

	ENDIF

ENDROUTINE  { smidi_op_no_choices }

{ ============================================================================= }
{ Routine configured within $SAMP_CONF to update smidi_phys_sample after login  }
{ and is used whenever a sample login is needed to make a new inspection point  }
{ ============================================================================= }

ROUTINE smidi_next_phys_no ( VALUE is_modify, VALUE action_type )

	DECLARE this_lot, phys_sample, prev, smidi_system, save_format, this_op

	IF action_type = "N" THEN

		this_lot     = STRIP ( SELECT SAMPLE.SMIDI_LOT )
		this_op      = STRIP ( SELECT SAMPLE.SMIDI_OPERATION )

		smidi_system = SELECT JOB_HEADER.SMIDI_REQUESTER
				WHERE JOB_NAME = SELECT SAMPLE.JOB_NAME

	
		IF this_lot <> EMPTY THEN

			phys_sample = SELECT MAX SMIDI_INSPPOINT.REQUEST_KEY
					WHERE REQUEST_KEY LIKE this_lot:this_op:"%"
					AND SMIDI_SYSTEM      = smidi_system
					AND SAP_POINT_CREATED = TRUE
 
			IF phys_sample = EMPTY THEN
	
				prev = "000001"

			ELSE

				save_format = GLOBAL ( "FORMAT_TEXT" )
				SET FORMAT "999999"
				prev = RIGHTSTRING ( "000000" : STRIP ( RIGHTSTRING ( STRIP(phys_sample), 6 ) + 1 ), 6 )
				SET FORMAT save_format

			ENDIF

		ENDIF

		ASSIGN SAMPLE.SMIDI_PHYS_SAMPLE = prev
	
	ENDIF  { action_type N - "NEW" sample ????? }

ENDROUTINE  { smidi_next_phys_no }

{ ---------------------------------------------------------------------------- }
GLOBAL ROUTINE migrate_smidi_request_records

	DECLARE a_rec, a_ray, cnt, tmpString, base_object, status, calling_report, com_cnt

	ARRAY a_ray

	calling_report = GLOBAL ( "CURRENT_LIBRARY" )

	smidi_lib_init(OPERATOR:PACKED_DECIMAL(1))
	smidi_lib_sap_define_base_class(1)

	CREATE OBJECT SMIDI_BASE_CLASS, base_object

	gbi_limits_initialise(1)
	smidi_qaimv_init(1)

	com_cnt = "Migrate"
	CALL_ROUTINE "smidi_lib_user_start" IN LIBRARY SMIDI_USER_LIB USING base_object, calling_report, com_cnt

	{ ------------------------------------------------------------------------ }
	{ Get all the srr's that have not been updated to the new format           }
	{ NOTE YOU WILL PROBABLY WANT TO SET UPLOAD_DEBUG to level 10 during this  }
	{ ------------------------------------------------------------------------ }

	cnt   = 0
	a_rec = SELECT SMIDI_REQUEST_RECORD.SMIDI_SYSTEM 
			WHERE SAP_RESULT_CONF_NO = " "
			ORDER ON SMIDI_LOT DESCENDING

	WHILE a_rec <> EMPTY DO

		cnt = cnt + 1

		a_ray[cnt,1] = SELECT SMIDI_REQUEST_RECORD.SMIDI_SYSTEM
		a_ray[cnt,2] = SELECT SMIDI_REQUEST_RECORD.REQUEST_KEY
		a_ray[cnt,3] = SELECT SMIDI_REQUEST_RECORD.RESULT_KEY
		a_ray[cnt,4] = SELECT SMIDI_REQUEST_RECORD.SAMPLE_KEY

		tmpString = SELECT SMIDI_REQUEST_RECORD.MESSAGE
		tmpString = smidi_lib_object_from_string ( "QAIMV", tmpString, base_object, 1 )

		a_ray[cnt,5 ] = tmpString.char_unit
		a_ray[cnt,6 ] = tmpString.decimal_places
		a_ray[cnt,7 ] = tmpString.cat_1_sset_group
		a_ray[cnt,8 ] = tmpString.subsys_valuates
		a_ray[cnt,9 ] = tmpString.need_subsamples
		a_ray[cnt,10] = tmpString.subsamp_val_type
		a_ray[cnt,11] = tmpString.serial_no_required
		a_ray[cnt,12] = tmpString.doc_required
		a_ray[cnt,13] = tmpString.result_type
		a_ray[cnt,14] = tmpString.valuation_type
		a_ray[cnt,15] = tmpString.inspection_scope
		a_ray[cnt,16] = tmpString.lot_no
		a_ray[cnt,17] = tmpString.result_number

	{	window_set_status ( cnt:a_ray[cnt,1]:a_ray[cnt,2]:a_ray[cnt,3]:a_ray[cnt,4]) }

		NEXT SMIDI_REQUEST_RECORD
		a_rec = SELECT SMIDI_REQUEST_RECORD.SAP_RESULT_CONF_NO

	ENDWHILE

	{ ------------------------------------------------------------- }
	{ Got all the data, now rewrite the data in one big honkin run  }
	{ ------------------------------------------------------------- }

	START WRITE TRANSACTION "SMIDI_SRR_CONVERT"

	com_cnt = 0
	cnt     = 1
	WHILE a_ray[cnt,1] <> EMPTY DO

		a_rec = SELECT SMIDI_REQUEST_RECORD.SMIDI_SYSTEM FOR UPDATE
				WHERE smidi_system = a_ray[cnt,1]
				AND   request_key  = a_ray[cnt,2]
				AND   result_key   = a_ray[cnt,3]
				AND   sample_key   = a_ray[cnt,4]

		IF a_rec <> EMPTY THEN

			ASSIGN SMIDI_REQUEST_RECORD.SAP_UNITS             = a_ray [ cnt, 5  ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_PLACES            = a_ray [ cnt, 6  ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_CODE_GROUP        = a_ray [ cnt, 7  ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_SUBSYS_VALUATES   = a_ray [ cnt, 8  ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_NEED_SUBSAMPS     = a_ray [ cnt, 9  ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_SUBSAMP_VALTYPE   = a_ray [ cnt, 10 ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_SERIAL_REQUIRED   = a_ray [ cnt, 11 ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_DOC_REQUIRED      = a_ray [ cnt, 12 ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_RESULT_TYPE       = a_ray [ cnt, 13 ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_VALUATE_TYPE      = a_ray [ cnt, 14 ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_INSPECT_SCOPE     = a_ray [ cnt, 15 ]
			ASSIGN SMIDI_REQUEST_RECORD.SMIDI_LOT             = a_ray [ cnt, 16 ]
			ASSIGN SMIDI_REQUEST_RECORD.SAP_RESULT_CONF_NO    = a_ray [ cnt, 17 ]

			UPDATE SMIDI_REQUEST_RECORD, status

			window_set_status ( cnt:a_ray[cnt,1]:a_ray[cnt,2]:a_ray[cnt,3]:a_ray[cnt,4])

		ENDIF

		cnt = cnt + 1

		IF ( com_cnt = 100 ) THEN
			COMMIT
			START WRITE TRANSACTION "SMIDI_SRR_CONVERT_":com_cnt
		ELSE
			com_cnt = com_cnt + 1
		ENDIF

	ENDWHILE

	COMMIT

	CALL_ROUTINE "smidi_lib_user_stop" IN LIBRARY SMIDI_USER_LIB USING base_object, calling_report
	EXIT

ENDROUTINE   { end migrate_smidi_request_records }

{*******************************************************************************}
{                                                                             											}
{                                                                             											}
{                                                                             											}
{  Menu/buttons for various options for SMIDI and the background services    				}
{                                                                             											}
{                                                                             											}
{                                                                             											}
{*******************************************************************************}

GLOBAL ROUTINE smidi_bg_service_menu( VALUE menu_num )

	{   Refresh the services}
	CALL_ROUTINE "refresh_services" IN LIBRARY BACKGROUND_LTE

	IF     menu_num = 29301 THEN		

		{ Show the Background services that are running }
		smidi_show_status()

	ELSEIF menu_num = 29302 THEN		

		{ Start all active background services }
		start_background_services(TYPE_ALL)

	ELSEIF menu_num = 29303 THEN		

		{ Stop all running background services}
		stop_background_services(TYPE_ALL)

	ELSEIF menu_num = 29311 THEN		
		
		{ Start all Download Services }
		start_background_services(TYPE_DOWNLOAD)
		
	ELSEIF menu_num = 29312 THEN

		{ Stop the running download services }
		stop_background_services(TYPE_DOWNLOAD)
		
	ELSEIF menu_num = 29321 THEN
		
		{ Start all Process services }
		start_background_services(TYPE_PROCESS)
		
	ELSEIF menu_num = 29322 THEN
		
		{ Stop the running Process services }
		stop_background_services(TYPE_PROCESS)

	ELSEIF menu_num = 29331 THEN
		
		{ Start all Upload services }
		start_background_services(TYPE_UPLOAD)

	ELSEIF menu_num = 29332 THEN
		
		{ Stop the running Process services }
		stop_background_services(TYPE_UPLOAD)

	ELSE

		FLASH_MESSAGE ( "Incorrect setup of menu ":menu_num, TRUE )

	ENDIF

ENDROUTINE    { smidi_explore_menu }

{******************************************************************************}

ROUTINE smidi_show_status

{ Show the status of the Background Processes
*
* Parameters   : None
*              
* Return Value : None
*
*******************************************************************************}  

	DECLARE spawn_str, status, userlist, tmpString, LOGFILE, QUAL_INTRO, KEYW_INTRO
	DECLARE SMPEXE, TWORD

	SMPEXE = "smp"
	TWORD = TRUE
	spawn_str = ""
	userlist  = ""

	IF GLOBAL ( "PLATFORM" ) = "UNIX" THEN

		LOGFILE = "$SMP_TEXTREPORTS/spawn" : STRIP ( GLOBAL ( "PROCESS_ID" )) : ".out"

		QUAL_INTRO = " -"
		KEYW_INTRO = " "

	ELSEIF GLOBAL ( "PLATFORM" ) = "VMS" THEN

		LOGFILE = "SMP$TEXTREPORTS:spawn" : STRIP ( GLOBAL ( "PROCESS_ID" )) : ".out"

		QUAL_INTRO = "/"
		KEYW_INTRO = "="

	ELSE

		LOGFILE = LIB_UTILS_LOGICAL_TO_STRING ( "SMP$TEXTREPORTS" ) : "\spawn" : STRIP ( GLOBAL ( "PROCESS_ID" )) : ".out"

		QUAL_INTRO = " -"
		KEYW_INTRO = " "

	ENDIF

	{ ============================================================================================ }
	{ Execute the show users and look for the SMIDI background processes                           }
	{ ============================================================================================ }

	CALL_ROUTINE "get_exe_path" IN LIBRARY "$SERVER_MANAGER" USING spawn_str, SMPEXE, TWORD
	RETURNING status

	IF status THEN

		IF ( GLOBAL ( "PLATFORM" ) = "NT" ) THEN
			spawn_str = spawn_str : QUAL_INTRO : "instance" : KEYW_INTRO : GLOBAL ( "INSTANCE" )
		ENDIF

		spawn_str = spawn_str : QUAL_INTRO : "users "

		WHILE NOT BLANK ( spawn_str ) DO

			userlist = "SM-IDI Background ":GLOBAL ( "INSTANCE" ):" ":NOW:ASCII(13)
			status   = lib_utils_spawn_with_log ( spawn_str, LOGFILE )

			IF ( status = EMPTY ) & ( FILE EXISTS ( LOGFILE ) ) THEN


				FILE OPEN LOGFILE, status

				WHILE status = EMPTY DO

					FILE READ LOGFILE, tmpString, status
					
					IF status = EMPTY THEN
					
						IF ( INDEX ( tmpString, "SMIDI" ) > 0 ) THEN
							userlist = userlist : STRIP (tmpString) : ASCII(13) : ASCII(10)
						ELSE
							userlist = userlist : tmpString : ASCII(13):ASCII(10)
						ENDIF
					ENDIF
	
				ENDWHILE

				FILE CLOSE LOGFILE, status
				FILE DELETE LOGFILE, status

			ENDIF { file exists from spawn }
	
			IF ( NOT confirm_with_text ( userlist ) ) THEN
				spawn_str = ""
			ENDIF

		ENDWHILE { spawn status emtpy and file exists }

	ENDIF  { get_exe_path }

ENDROUTINE  { smidi_show_status }


{******************************************************************************}

ROUTINE start_background_services(VALUE theType)

{ Start all of the services that are active
*
* Parameters   : None
*              
* Return Value : None
*
*******************************************************************************}  
	DECLARE backgroundObj, backgroundRec,backgroundServ, theMode
	DECLARE exePath, instance,report, svcTemplate, smpTemplate, processID, logLoc, maxAttempts
	
	START WRITE TRANSACTION "Starting IDI Background Services"
					
	{ Select the services to start  - dependent upon the type}
	IF( theType = TYPE_ALL) THEN
		backgroundRec = SELECT SMIDI_BACKGROUND.SERVICE FOR UPDATE WHERE ACTIVE = "TRUE" AND RUNNING = "FALSE" AND REMOVEFLAG = "FALSE"
	ELSE
		backgroundRec = SELECT SMIDI_BACKGROUND.SERVICE FOR UPDATE WHERE TYPE = theType AND ACTIVE = "TRUE" AND RUNNING = "FALSE" AND REMOVEFLAG = "FALSE"
	ENDIF

	IF (backgroundRec <> EMPTY) THEN
		WHILE (backgroundRec <> EMPTY) 

			{ Create the object to call the dll }
			CREATE OBJECT "STD_OLE_AUTOMATION_SERVER", backgroundObj
			 backgroundObj . create ("Thermo.SM.SMIDI.Background.SMIDIBackground")
			 
			{ Build up the variables that will be passed }
			IF ((SELECT SMIDI_BACKGROUND.CREATE_SERVICE) = "TRUE") THEN	{ Mode }
				theMode = "CREATE"
			ELSE
				theMode = "START"
			ENDIF

			instance =  STRIP (SELECT SMIDI_BACKGROUND.INSTANCE) 		{ Instance }
			backgroundServ = STRIP(SELECT SMIDI_BACKGROUND.SERVICE)		{ Name of the Service }
			report = BACKGROUND_LIBRARY 									{ report }
			svcTemplate = SELECT SMIDI_BACKGROUND.SERV_TEMPL			{ Service Template }
			smpTemplate = SELECT SMIDI_BACKGROUND.SMP_TEMPL			{ smp Template } 
			processID = SELECT SMIDI_BACKGROUND.PROCESS_ID				{ Process }
			logLoc = SELECT SMIDI_BACKGROUND.LOG_LOC					{Logfile Location} 
			maxAttempts = SELECT SMIDI_BACKGROUND.MAX_RETRY			{ Max number of Process retry }

			exePath =  LIB_UTILS_LOGICAL_CONTAINING_FILE ( "SMP$PROGRAMS", svcTemplate ):"\"	{  Path}

			{ Add the variables to the Background }
			backgroundObj.AddParameter(theMode, 0)
			backgroundObj.AddParameter(STRIP(exePath), 1)
			backgroundObj.AddParameter(instance, 2)                                                                       
			backgroundObj.AddParameter(backgroundServ, 3)                                                                 
			backgroundObj.AddParameter(report, 4) 
			backgroundObj.AddParameter(svcTemplate, 5) 
			backgroundObj.AddParameter(smpTemplate, 6)          
			backgroundObj.AddParameter(processID, 7) 
			backgroundObj.AddParameter(STRIP(logLoc), 8) 
			backgroundObj.AddParameter(maxAttempts, 9)    

			 { Create/Start the Service(s) }
			 IF (backgroundObj . InvokeBackgroundService() = "TRUE") THEN
			
				{ Set the attributes for the Service now that it is running }
				IF theMode = "CREATE" THEN
					ASSIGN SMIDI_BACKGROUND.CREATE_SERVICE = "FALSE"
				ENDIF

				ASSIGN SMIDI_BACKGROUND.RUNNING = "TRUE"
				UPDATE SMIDI_BACKGROUND	

			ELSE

				ROLLBACK 	

			ENDIF
	
			NEXT SMIDI_BACKGROUND
			backgroundRec = SELECT SMIDI_BACKGROUND.SERVICE

		ENDWHILE
	
	ELSE
		FLASH_MESSAGE( GET_USER_MESSAGE ( "SMIDI_BACKGROUND_BG", 29 ), MSG_LOW )
	ENDIF
	
	COMMIT 	
	
ENDROUTINE


{******************************************************************************}

ROUTINE stop_background_services(VALUE theType)

{ Stops all of the services that are active
*
* Parameters   : None
*              
* Return Value : None
*
*******************************************************************************}  

	DECLARE backgroundObj, backgroundRec
	DECLARE theMode, exePath, instance, backgroundServ
	
	
	START WRITE TRANSACTION "Stopping IDI Background Services"
	
	{ Select the services to stop - dependent upon the type }
	IF (theType = TYPE_ALL) THEN
		backgroundRec = SELECT SMIDI_BACKGROUND.SERVICE FOR UPDATE WHERE ACTIVE = "TRUE" AND RUNNING = "TRUE" AND REMOVEFLAG = "FALSE"
	ELSE
		backgroundRec = SELECT SMIDI_BACKGROUND.SERVICE FOR UPDATE WHERE TYPE = theType AND ACTIVE = "TRUE" AND RUNNING = "TRUE" AND REMOVEFLAG = "FALSE"
	ENDIF
		
	IF (backgroundRec <> EMPTY) THEN
		WHILE (backgroundRec <> EMPTY) 

			{ Create the object to call the dll }
			CREATE OBJECT "STD_OLE_AUTOMATION_SERVER" , backgroundObj
			backgroundObj . create ("Thermo.SM.SMIDI.Background.SMIDIBackground")
			
			{ Build up the variables that will be passed }
			theMode = "STOP"
			instance = STRIP (SELECT SMIDI_BACKGROUND.INSTANCE)			{ Instance }				
			backgroundServ = STRIP(SELECT SMIDI_BACKGROUND.SERVICE)		{ Name of the Service }

			exePath =  LIB_UTILS_LOGICAL_CONTAINING_FILE ( "SMP$PROGRAMS", SELECT SMIDI_BACKGROUND.SERV_TEMPL ):"\"	{  Path}

			{ Add the variables to the Background }
			backgroundObj.AddParameter(theMode, 0)
			backgroundObj.AddParameter(exePath, 1)
			backgroundObj.AddParameter(instance, 2)
			backgroundObj.AddParameter(backgroundServ, 3)

			{ Stop the Service(s) }
			IF (backgroundObj.InvokeBackgroundService()) THEN

				ASSIGN SMIDI_BACKGROUND.RUNNING = "FALSE"
				UPDATE SMIDI_BACKGROUND

			ELSE

				ROLLBACK

			ENDIF

			NEXT SMIDI_BACKGROUND
			backgroundRec = SELECT SMIDI_BACKGROUND.SERVICE

		ENDWHILE
	
	ELSE
		FLASH_MESSAGE( GET_USER_MESSAGE ( "SMIDI_BACKGROUND_BG", 28 ), MSG_LOW )
	ENDIF
	
	COMMIT
	
ENDROUTINE


{******************************************************************************}

ROUTINE start_background

	spare = find_smidi_service()
	FLASH_MESSAGE ( "SPAWNING COMMAND ->  NET START ":spare, TRUE )

	tmpString = LIB_UTILS_LOGICAL_TO_STRING ( "smp$logfiles" ) : "\smidi_netstart.log"
	tmpString = lib_utils_spawn_with_log ( "net start ":spare, tmpString )

	window_set_status ( tmpString )

ENDROUTINE  { start_background }

{******************************************************************************}

ROUTINE stop_background

	spare = find_smidi_service()
	FLASH_MESSAGE ( "SPAWNING COMMAND ->  NET STOP ":spare, TRUE )

	tmpString = LIB_UTILS_LOGICAL_TO_STRING ( "smp$logfiles" ) : "\smidi_netstop.log"
	tmpString = lib_utils_spawn_with_log ( "net stop ":spare, tmpString )

	window_set_status ( tmpString )

ENDROUTINE  { stop_background }

{******************************************************************************}

ROUTINE find_smidi_service

	tmpString = SMIDI_SERVICE_PREFIX : GLOBAL ( "INSTANCE" )
	RETURN ( tmpString )

ENDROUTINE  { find_smidi_service }

{*****************************************************************************}

GLOBAL ROUTINE smidi_explore_rmb( self, object, data )

	DECLARE menu_num, object_type, a_table
	

	a_table  = "EXPLORER_RMB"
	retval   = FALSE
	menu_num = SELECT 'a_table'.MENUPROC IN OBJECT object

	IF data = EMPTY THEN
		object_type = "somehow user called this from the wrong place"
	ELSE
		object_type = OBJECT_GET_CLASS_NAME ( data )
	ENDIF

	{ ----------------------------------------------------------------------------- }
	{ the menu number decides which option and what data from the selection we use  }
	{ ----------------------------------------------------------------------------- }

	IF object_type <> "STDOBJECTDATABASE" THEN

		FLASH_MESSAGE ( "Pick this menu from the list and not the tree please-> ":object_type, TRUE )

	ELSEIF menu_num = 29501 THEN
		
		{ reset download queue }
		retval = smidi_rmb_option( self, object, data, "reset_smidi_download_queue", "SMIDI_DOWNLOAD_QUEUE", "SAP_LOT" )
	
	ELSEIF menu_num = 29502 THEN
	
		{ Delete uplaod queue }
		retval = smidi_rmb_option( self, object, data, "delete_smidi_record", "SMIDI_DOWNLOAD_QUEUE", "SAP_LOT" )
		
	ELSEIF menu_num = 29503 THEN
		
		{ Reset upload queue }
		retval = smidi_rmb_option( self, object, data, "reset_smidi_upload_queue", "SMIDI_UPLOAD_QUEUE", "TEST_NUMBER" )
	
	ELSEIF menu_num = 29504 THEN
		
		{ Delete upload queue }
		retval = smidi_rmb_option(self, object, data, "delete_smidi_record", "SMIDI_UPLOAD_QUEUE", "TEST_NUMBER" )
	
	ELSEIF menu_num = 29505 THEN
		
		{ Display the Log File }
		retval = smidi_rmb_option( self, object, data, "display_smidi_logfile", "SMIDI_LOGFILES", "SMIDI_LOGFILE" )
	
	ELSEIF menu_num = 29506 THEN
		
		{ Delete the log file }
		retval = smidi_rmb_option( self, object, data, "delete_smidi_logfile", "SMIDI_LOGFILES", "SMIDI_LOGFILE" )
	
	ELSEIF menu_num = 29507 THEN
	
		{ Delete the log file record }
		retval = smidi_rmb_option( self, object, data, "delete_smidi_record", "SMIDI_LOGFILES", "SMIDI_LOGFILE" )
	
	ELSEIF menu_num = 29508 THEN
	
		{ Delete the logfile and record  }
		retval = smidi_rmb_option( self, object, data, "delete_smidi_logfile_n_record", "SMIDI_LOGFILES", "SMIDI_LOGFILE" )
	
	ELSEIF menu_num = 29509 THEN
	
		{ Delete status queue }
		retval = smidi_rmb_option( self, object, data, "delete_smidi_record", "STATUS_QUEUE", "IDENTITY" )
	
	ELSE

		FLASH_MESSAGE ( "Incorrect setup of RMB option ":menu_num, TRUE )

	ENDIF

	RETURN ( retval )

ENDROUTINE    { smidi_explore_rmb }


{*****************************************************************************}

ROUTINE smidi_rmb_option( explorer_rmb, record_object, collection, VALUE the_routine, VALUE the_table, VALUE the_field )

	DECLARE the_id

	retval = TRUE

	IF collection.size() > 1 THEN

		collection.set_first()

		WHILE ( collection.current <> EMPTY ) & ( retval ) DO

			the_id = SELECT 'the_table'.'the_field' IN OBJECT collection.current

			IF the_id <> EMPTY THEN
				CALL_ROUTINE the_routine IN LIBRARY "$SMIDI_LIB_SAP" 
					USING explorer_rmb, record_object, collection
					RETURNING retval
			ENDIF

			collection.set_next()
	
		ENDWHILE

	ELSE

		collection.set_first()

		IF collection.current <> EMPTY THEN
	
			the_id = SELECT 'the_table'.'the_field' IN OBJECT collection.current

			IF the_id <> EMPTY THEN
				CALL_ROUTINE the_routine IN LIBRARY "$SMIDI_LIB_SAP" 
					USING explorer_rmb, record_object, collection
					RETURNING retval

			ENDIF

		ENDIF

	ENDIF

	RETURN ( retval )

ENDROUTINE

{******************************************************************************}

ROUTINE delete_smidi_record ( explorer_rmb, record_object, collection )

	retval = collection.current.delete()
	RETURN ( retval <> EMPTY )

ENDROUTINE  { delete_smidi_record }

{******************************************************************************}

ROUTINE reset_smidi_upload_queue ( explorer_rmb, record_object, collection )

	ASSIGN SMIDI_UPLOAD_QUEUE.STATUS      IN OBJECT collection.current = 1
	ASSIGN SMIDI_UPLOAD_QUEUE.RETRY_COUNT IN OBJECT collection.current = 0

	RETURN ( TRUE )

ENDROUTINE  { reset_smidi_upload_queue }

{******************************************************************************}

ROUTINE reset_smidi_download_queue ( explorer_rmb, record_object, collection )

	retval    = FALSE
	tmpString = SELECT SMIDI_DOWNLOAD_QUEUE.PROCESSED IN OBJECT collection.current

	IF tmpString <> EMPTY THEN

		ASSIGN SMIDI_DOWNLOAD_QUEUE.PROCESSED   IN OBJECT collection.current = NOT tmpString
		ASSIGN SMIDI_DOWNLOAD_QUEUE.RETRY_COUNT IN OBJECT collection.current = 0
		retval                                                               = TRUE

	ENDIF

	RETURN ( retval )

ENDROUTINE   { reset download_queue }

{******************************************************************************}

ROUTINE display_smidi_logfile ( explorer_rmb, record_object, collection )

	tmpString = SELECT SMIDI_LOGFILES.SMIDI_LOGFILE IN OBJECT collection.current

	IF FILE EXISTS ( tmpString ) THEN
		FILE SEND tmpString, "DISPLAY/"
	ELSE
		FLASH_MESSAGE ( "display_smidi_logfile file does not exist " : tmpString, TRUE )
	ENDIF

	RETURN ( TRUE )

ENDROUTINE  { display_smidi_logfile }

{******************************************************************************}

ROUTINE delete_smidi_logfile ( explorer_rmb, record_object, collection )

	DECLARE status

	tmpString = SELECT SMIDI_LOGFILES.SMIDI_LOGFILE IN OBJECT collection.current

	FILE DELETE tmpString, status

	RETURN ( TRUE )

ENDROUTINE  { delete_smidi_logfile }

{******************************************************************************}

ROUTINE delete_smidi_logfile_n_record ( explorer_rmb, record_object, collection )

	retval = delete_smidi_logfile ( explorer_rmb, record_object, collection )
	retval = delete_smidi_record  ( explorer_rmb, record_object, collection )

	RETURN ( retval )

ENDROUTINE  { delete_smidi_logfile_n_record }

{******************************************************************************}

ROUTINE delete_smidi_LOT_download_queue ( explorer_rmb, record_object, collection )

	{ ------------------------------------------------------------------------------- }
	{ Rebuild the select based on a field in the current single line and loop on each }
	{ ------------------------------------------------------------------------------- }

	retval    = TRUE
	tmpString = SELECT SMIDI_DOWNLOAD_QUEUE.SAP_LOT IN OBJECT collection.current

	WHILE ( tmpString <> EMPTY ) & ( retval ) DO

		FLASH_MESSAGE ( "delete_smidi_lot_download_queue " : tmpString, TRUE )

		retval = delete_smidi_record ( explorer_rmb, record_object, collection ) 
		collection.current.set_next()

	ENDWHILE

	RETURN ( retval )

ENDROUTINE  { delete_smidi_LOT_download_queue }

{******************************************************************************}

ROUTINE reset_smidi_LOT_download_queue ( explorer_rmb, record_object, collection )

	{ ------------------------------------------------------------------------------- }
	{ Rebuild the select based on a field in the current single line and loop on each }
	{ ------------------------------------------------------------------------------- }

	retval    = TRUE
	tmpString = SELECT SMIDI_DOWNLOAD_QUEUE.SAP_LOT IN OBJECT collection.current

	WHILE ( tmpString <> EMPTY ) & ( retval ) DO

		FLASH_MESSAGE ( "reset_smidi_lot_download_queue " : tmpString, TRUE )

		retval = reset_smidi_download_queue ( explorer_rmb, record_object, collection ) 
		collection.current.set_next()

	ENDWHILE

	RETURN ( retval )

ENDROUTINE   { reset_smidi_LOT_download_queue }

{ ===================================================================================== }
{                                                                                       }
{                         Q M I D I      I N T E R F A C E                              }
{                                                                                       }
{ ===================================================================================== }


ROUTINE r3_get_table ( VALUE tab_name, rows )

	DECLARE count, temp, stat

	array rows
	count = 1
	stat  = r3_get_table_row( tab_name, count, temp )

	WHILE (stat = SMIDI_NORMAL) DO
		rows[ count ] = temp
		count = count + 1
		stat = r3_get_table_row( tab_name, count, temp )
	ENDWHILE

	IF (stat = SMIDI_LASTROW) THEN
		rows[ count ] = temp
		stat = SMIDI_NORMAL
	ENDIF
	IF (stat = SMIDI_BADROW) THEN
		stat = SMIDI_NORMAL
	ENDIF

	return( stat )

ENDROUTINE     { r3_get_table }

{ ======================================================================================================= }

ROUTINE r3_put_table ( VALUE tab_name, rows )

	DECLARE count, temp

	count   = 1
	retval  = SMIDI_NORMAL

	WHILE (rows[ count ] <> empty) AND (retval = SMIDI_NORMAL) DO

		temp   = rows[ count ]
 		retval = r3_add_table_row( tab_name, temp )
		count  = count + 1

	ENDWHILE

	return( retval )

ENDROUTINE    { r3_put_table }

{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_commit

	retval = r3_prepare_call( 0, 0, 0 )

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_call( "QIRF_SEND_COMMIT_TO_QM" )

		spare = r3_cleanup_call( )

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF

	ENDIF

	return( retval )

ENDROUTINE    { alt_idi_commit }

{ ======================================================================================================= }
{                                                                                                         }
{                      D O W N L O A D   I N S P E C T I O N    L O T S                                   }
{                                                                                                         }
{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_QIRF_SEND_INSP_REQUIRMENTS ( self ) 

	DECLARE qails_string, a_len

	retval       = r3_prepare_call( 4, 0, 1 )
	qails_string = smidi_lib_object_to_string ( self.query.qails )
	a_len        = self.A1_base.smidi_qirf[self.qmidi_object].QAILS

	r3_set_export_param( 1, "I_IND_MULTI_TRANSFER_POSSIBLE", R3_TYPC, 1    , self.query.allow_corrections )
	r3_set_export_param( 2, "I_IND_SORT_ASCENDING_TO_DATE" , R3_TYPC, 1    , self.query.sort_ascending    )
	r3_set_export_param( 3, "I_IND_SORT_DESCENDING_TO_DATE", R3_TYPC, 1    , self.query.sort_descending   )
	r3_set_export_param( 4, "I_QAILS"                      , R3_TYPC, a_len, qails_string   )

	a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QIWLR
	retval = r3_define_table( "T_QIWLTAB", R3_TYPC, a_len )

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_call( "QIRF_SEND_INSP_REQUIRMENTS" )

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QIWLTAB", self.worklist )
		ENDIF

		spare = r3_cleanup_call()

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF
	ENDIF

	return( retval )

ENDROUTINE    { alt_idi_QIRF_SEND_INSP_REQUIRMENTS }

{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_QIRF_SEND_INSP_DATA_FOR_WL ( self )

	DECLARE mail, a_len

	smidi_lib_array_to_string ( self.worklist, self.worklist )

	mail   = set_flag ( self.get_item ( "QM_DNL_MAIL" ) )
	retval = r3_prepare_call( 11, 0, 5 )
	a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QAICA

 	r3_set_export_param( 1 , "I_IND_EVALUATE_CHARACTERISTIC" , R3_TYPC, 1, self.query.get_valuation     )
 	r3_set_export_param( 2 , "I_IND_MULTI_TRANSFER_POSSIBLE" , R3_TYPC, 1, self.query.allow_corrections )
 	r3_set_export_param( 3 , "I_IND_ONLY_OBLIGATORY_CHARACT" , R3_TYPC, 1, self.query.get_required      )
 	r3_set_export_param( 4 , "I_IND_READ_PURCHASING_INFO"    , R3_TYPC, 1, self.query.get_purchasing    )
 	r3_set_export_param( 5 , "I_IND_READ_SALES_INFO"         , R3_TYPC, 1, self.query.get_sales         )
 	r3_set_export_param( 6 , "I_IND_READ_VENDOR_AND_PRODUCER", R3_TYPC, 1, self.query.get_vendor        )
 	r3_set_export_param( 7 , "I_IND_READ_WORK_CENTER"        , R3_TYPC, 1, self.query.get_work_centre   )
 	r3_set_export_param( 8 , "I_IND_SEND_PROTOCOL_MAIL"      , R3_TYPC, 1, mail                         )
 	r3_set_export_param( 9 , "I_IND_SET_BLOCK_INDICATORS"    , R3_TYPC, 1, self.query.lock_chars        )
 	r3_set_export_param( 10, "I_IND_TRANSFER_CHAR_CODES"     , R3_TYPC, 1, self.query.get_res_cat       )
 	r3_set_export_param( 11, "I_IND_TRANSFER_USAGE_DEC_CODES", R3_TYPC, 1, self.query.get_ud_cat        )

	retval = r3_define_table( "T_QAICATAB", R3_TYPC, a_len )

	IF (SMIDI_NORMAL = retval) THEN
		a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QAIMV
		retval = r3_define_table( "T_QAIMVTAB", R3_TYPC, a_len )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QAIVC
		retval = r3_define_table( "T_QAIVCTAB", R3_TYPC, a_len )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QIERR
		retval = r3_define_table( "T_QIERRTAB", R3_TYPC, a_len )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QIWLR
		retval = r3_define_table( "T_QIWLTAB" , R3_TYPC, a_len )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_put_table( "T_QIWLTAB", self.worklist )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		IF self.qmidi_object = 1 THEN
			retval = r3_call( "QIRF_SEND_INSP_DATA_FOR_WL" )
		ELSE
			retval = r3_call( "QIRF_SEND_INSP_DATA_FOR_WL2" )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QAICATAB", self.phrases )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QAIVCTAB", self.operations )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QAIMVTAB", self.chars   )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QIERRTAB", self.errors  ) 
		ENDIF

		spare = r3_cleanup_call()

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF
	ENDIF

	return( retval )

ENDROUTINE   { alt_idi_QIRF_SEND_INSP_DATA_FOR_WL }

{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_QIRF_SEND_REQUIRMENTS_GET_DATA ( self )

	DECLARE mail, a_len, tmpString

	tmpString = smidi_lib_object_to_string ( self.query.qails )
	a_len     = STRINGLENGTH ( tmpString )
	mail      = set_flag ( self.get_item ( "QM_DNL_MAIL" ) )
	retval    = r3_prepare_call( 14, 0, 4 )

 	r3_set_export_param( 1 , "I_IND_EVALUATE_CHARACTERISTIC" , R3_TYPC, 1    , self.query.get_valuation     )
 	r3_set_export_param( 2 , "I_IND_MULTI_TRANSFER_POSSIBLE" , R3_TYPC, 1    , self.query.allow_corrections )
 	r3_set_export_param( 3 , "I_IND_ONLY_OBLIGATORY_CHARACT" , R3_TYPC, 1    , self.query.get_required      )
 	r3_set_export_param( 4 , "I_IND_READ_PURCHASING_INFO"    , R3_TYPC, 1    , self.query.get_purchasing    )
 	r3_set_export_param( 5 , "I_IND_READ_SALES_INFO"         , R3_TYPC, 1    , self.query.get_sales         )
 	r3_set_export_param( 6 , "I_IND_READ_VENDOR_AND_PRODUCER", R3_TYPC, 1    , self.query.get_vendor        )
 	r3_set_export_param( 7 , "I_IND_READ_WORK_CENTER"        , R3_TYPC, 1    , self.query.get_work_centre   )
 	r3_set_export_param( 8 , "I_IND_SEND_PROTOCOL_MAIL"      , R3_TYPC, 1    , mail                         )
 	r3_set_export_param( 9 , "I_IND_SET_BLOCK_INDICATORS"    , R3_TYPC, 1    , self.query.lock_chars        )
 	r3_set_export_param( 10, "I_IND_SORT_ASCENDING_TO_DATE"  , R3_TYPC, 1    , self.query.sort_ascending    )
 	r3_set_export_param( 11, "I_IND_SORT_DESCENDING_TO_DATE" , R3_TYPC, 1    , self.query.sort_descending   )
 	r3_set_export_param( 12, "I_IND_TRANSFER_CHAR_CODES"     , R3_TYPC, 1    , self.query.get_res_cat       )
 	r3_set_export_param( 13, "I_IND_TRANSFER_USAGE_DEC_CODES", R3_TYPC, 1    , self.query.get_ud_cat        )
 	r3_set_export_param( 14, "I_QAILS"                       , R3_TYPC, a_len, tmpString                    )

	a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QAICA
	retval = r3_define_table( "T_QAICATAB", R3_TYPC, a_len )

	IF (SMIDI_NORMAL = retval) THEN
		a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QAIMV
		retval = r3_define_table( "T_QAIMVTAB", R3_TYPC, a_len )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QAIVC
		retval = r3_define_table( "T_QAIVCTAB", R3_TYPC, a_len )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		a_len  = self.A1_base.smidi_qirf[self.qmidi_object].QIERR
		retval = r3_define_table( "T_QIERRTAB", R3_TYPC, a_len )
	ENDIF


	IF (SMIDI_NORMAL = retval) THEN

		IF self.qmidi_object = 1 THEN
			retval = r3_call( "QIRF_SEND_REQUIRMENTS_GET_DATA" )
		ELSE
			retval = r3_call( "QIRF_SEND_REQUIRMENTS_GET_DATA2" )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QAICATAB", self.phrases )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QAIVCTAB", self.operations )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QAIMVTAB", self.chars   )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QIERRTAB", self.errors  ) 
		ENDIF

		spare = r3_cleanup_call()

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF

	ENDIF

	return( retval )

ENDROUTINE   { alt_idi_QIRF_SEND_REQUIRMENTS_GET_DATA }

{ ======================================================================================================= }
{                                                                                                         }
{                       S E L E C T E D   S E T S   --    P H R A S E S                                   }
{                                                                                                         }
{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_get_phrases ( VALUE alt_idi_param01 ,
			      VALUE alt_idi_param02 ,
			      VALUE alt_idi_param03 ,
			      VALUE alt_idi_param04 ,
			      VALUE alt_idi_param05 ,
			      VALUE alt_idi_param06 ,
			            phrases         ,
			            errors          ,
				    self            )

	retval = r3_prepare_call( 6, 0, 2 )

	spare = r3_set_export_param( 1, "I_CATALOG"                 , R3_TYPC, 8, alt_idi_param01 )
	spare = r3_set_export_param( 2, "I_CATALOG_TYPE"            , R3_TYPC, 1, alt_idi_param02 )
	spare = r3_set_export_param( 3, "I_IND_CATALOG_IS_CODEGROUP", R3_TYPC, 1, alt_idi_param03 )
	spare = r3_set_export_param( 4, "I_IND_CATALOG_IS_SEL_SET"  , R3_TYPC, 1, alt_idi_param04 )
	spare = r3_set_export_param( 5, "I_LANGUAGE"                , R3_TYPC, 1, alt_idi_param05 )
	spare = r3_set_export_param( 6, "I_PLANT_OF_SELECTED_SET"   , R3_TYPC, 4, alt_idi_param06 )

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_define_table( "T_QAICATAB", R3_TYPC, self.smidi_qirf[self.qmidi_object].qaica )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_define_table( "T_QIERRTAB", R3_TYPC, self.smidi_qirf[self.qmidi_object].qierr )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		IF self.qmidi_object = 1 THEN
			retval = r3_call( "QIRF_SEND_CATALOG_DATA" )
		ELSE
			retval = r3_call( "QIRF_SEND_CATALOG_DATA2" )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QAICATAB", phrases )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QIERRTAB", errors )
		ENDIF

		spare = r3_cleanup_call( )

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF

	ENDIF

	return( retval )

ENDROUTINE   { alt_idi_get_phrases }

{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_get_catalog_types ( cat_types, self )

	DECLARE retval, spare

	retval = r3_prepare_call( 0, 0, 1 )

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_define_table( "T_TQ15TTAB", R3_TYPC, idi_cat_type_length )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_call( "QIRF_SEND_CATALOG_TYPES" )

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_TQ15TTAB", cat_types )
		ENDIF

		spare = r3_cleanup_call( )

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF

	ENDIF

	return( retval )

ENDROUTINE    { alt_idi_get_catalog_types }

{ ======================================================================================================= }
{                                                                                                         }
{                     D E F E C T      O R       R E S U L T    U P L O A D                               }
{                                                                                                         }
{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_upload_results_or_defects ( self, subsys, VALUE qm_table, VALUE qm_call, qm_array )

	DECLARE len_qm

	len_qm = STRINGLENGTH ( qm_array[1] )
	retval = r3_prepare_call( 6, 0, 2 )

	r3_set_export_param( 1, "I_IND_CLOSE_PROCESSING"   , R3_TYPC, 1, self.close   )
	r3_set_export_param( 2, "I_IND_EVALUATION_TRANSFER", R3_TYPC, 1, self.valuate )
	r3_set_export_param( 3, "I_IND_POSTING_KZ"         , R3_TYPC, 1, self.update  )
	r3_set_export_param( 4, "I_IND_PROC_COMMIT_WORK"   , R3_TYPC, 1, self.commit  )
	r3_set_export_param( 5, "I_SEND_PROTOCOL_MAIL"     , R3_TYPC, 1, self.mail    )
	r3_set_export_param( 6, "I_SUBSYS"                 , R3_TYPC, 6, subsys       )

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_define_table( qm_table, R3_TYPC, len_qm )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_define_table( "T_QIERRTAB", R3_TYPC, self.A1_base.smidi_qirf[self.A1_base.qmidi_object].QIERR )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_put_table( qm_table, qm_array )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		IF self.A1_base.qmidi_object = 1 THEN
			retval = r3_call( qm_call     )
		ELSE
			retval = r3_call( qm_call:"2" )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QIERRTAB", self.errors )
		ENDIF

		spare = r3_cleanup_call( )

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF

	ENDIF

	return( retval )

ENDROUTINE    { alt_idi_upload_results_or_defects }

{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_QIRF_GET_ALL_DATA_VALUES ( self, subsys )

	retval = r3_prepare_call( 6, 0, 4 )

	r3_set_export_param( 1, "I_IND_CLOSE_PROCESSING"   , R3_TYPC, 1, self.close   )
	r3_set_export_param( 2, "I_IND_EVALUATION_TRANSFER", R3_TYPC, 1, self.mail    )
	r3_set_export_param( 3, "I_IND_POSTING_KZ"         , R3_TYPC, 1, self.posting )
	r3_set_export_param( 4, "I_IND_PROC_COMMIT_WORK"   , R3_TYPC, 1, self.commit  )
	r3_set_export_param( 5, "I_SEND_PROTOCOL_MAIL"     , R3_TYPC, 1, self.mail    )
	r3_set_export_param( 6, "I_SUBSYS"                 , R3_TYPC, 6, subsys       )

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_define_table( "T_QAIMRTAB", R3_TYPC, self.smidi_qirf[self.qmidi_object].QAIMR )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_define_table( "T_QAISETAB", R3_TYPC, self.smidi_qirf[self.qmidi_object].QAISE )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_define_table( "T_QAISRTAB", R3_TYPC, self.smidi_qirf[self.qmidi_object].QAISR )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_define_table( "T_QIERRTAB", R3_TYPC, self.smidi_qirf[self.qmidi_object].QIERR )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_put_table( "T_QAIMRTAB", self.mr_array )
	ENDIF
	
	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_put_table( "T_QAISETAB", self.se_array )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN
		retval = r3_put_table( "T_QAISRTAB", self.sr_array )
	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		IF self.qmidi_object = 1 THEN
			retval = r3_call( "QIRF_GET_ALL_DATA_VALUES" )
		ELSE
			retval = r3_call( "QIRF_GET_ALL_DATA_VALUES2" )
		ENDIF
	
		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QIERRTAB", self.errors )
		ENDIF

		spare = r3_cleanup_call()

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF

	ENDIF

	return( retval )

ENDROUTINE      { alt_idi_QIRF_GET_ALL_DATA_VALUES }

{ ======================================================================================================= }
{                                                                                                         }
{     C A N C E L    L O T    O R    M A K E   U S A G E    D E C I S I O N S                             }
{                                                                                                         }
{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_QIRF_GET_USAGE_DECISION ( self, subsys )

	retval = r3_prepare_call( 3, 0, 2 )

	r3_set_export_param( 1, "I_SEND_PROTOCOL_MAIL", R3_TYPC, 1, self.mail   )
	r3_set_export_param( 2, "I_STOCK_POSTING"     , R3_TYPC, 1, self.update )
	r3_set_export_param( 3, "I_SUBSYS"            , R3_TYPC, 6, subsys      )

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_define_table( "T_QAIVETAB", R3_TYPC, self.A1_base.smidi_qirf[self.qmidi_object].QAIVE )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_define_table( "T_QIERRTAB", R3_TYPC, self.A1_base.smidi_qirf[self.qmidi_object].QIERR )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_put_table( "T_QAIVETAB", self.qaive )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		IF self.qmidi_object = 1 THEN
			retval = r3_call( "QIRF_GET_USAGE_DECISION" )
		ELSE
			retval = r3_call( "QIRF_GET_USAGE_DECISION2" )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QIERRTAB", self.errors )
		ENDIF

		spare = r3_cleanup_call( )
	
		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF

	ENDIF

	return( retval )

ENDROUTINE   { alt_idi_QIRF_GET_USAGE_DECISION }

{ ======================================================================================================= }
{                                                                                                         }
{     C R E A T E    P O I N T S    O R    M A K E   P O I N T   U S A G E    D E C I S I O N S           }
{                                                                                                         }
{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_points ( self, subsys, VALUE qm_table, VALUE qm_call, qm_array )

	retval = r3_prepare_call( 2, 0, 2 )
	r3_set_export_param( 1, "I_SEND_PROTOCOL_MAIL", R3_TYPC, 1, self.mail )
	r3_set_export_param( 2,  "I_SUBSYS"           , R3_TYPC, 6, subsys    )

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_define_table( qm_table, R3_TYPC, self.A1_base.smidi_qirf[self.qmidi_object].QAIPP )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_define_table( "T_QIERRTAB", R3_TYPC, self.A1_base.smidi_qirf[self.qmidi_object].QIERR )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		retval = r3_put_table( qm_table, qm_array )

	ENDIF

	IF (SMIDI_NORMAL = retval) THEN

		IF self.qmidi_object = 1 THEN
			retval = r3_call( qm_call     )
		ELSE
			retval = r3_call( qm_call:"2" )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_get_table( "T_QIERRTAB", self.errors )
		ENDIF

		spare = r3_cleanup_call()

		IF (SMIDI_NORMAL = retval) THEN
			retval = spare
		ENDIF

	ENDIF

	return( retval )

ENDROUTINE    { alt_idi_points }

{ ======================================================================================================= }

GLOBAL ROUTINE alt_idi_QIRF_INSPPOINT_GETLIST ( self )

	retval = r3_prepare_call( 5, 0, 2 )

	r3_set_export_param( 1, "INSPLOT"       , R3_TYPC, 12, self.query.from_ip_lot      )
	r3_set_export_param( 2, "INSPOPER"      , R3_TYPC, 4 , self.query.from_ip_op_no    )
	r3_set_export_param( 3, "INSPPOINT_FROM", R3_TYPC, 6 , self.query.from_ip_point    )
	r3_set_export_param( 4, "INSPPOINT_TO"  , R3_TYPC, 6 , self.query.to_ip_point      )
	r3_set_export_param( 5, "I_SUBSYS"      , R3_TYPC, 6 , self.query.smidi_subsystem  )

	IF (SMIDI_NORMAL = retval) THEN


		{ -*-*-*-*-*-*-*-*-*-*-*-*-*-*----------------------------------- }
                {                                                                 }
		{ ONLY DOES VERSION 2 objects - this call is not in Version 1 DLL }
                {                                                                 }
		{ _*_*_*_*_*_*_*_*_*_*_*_*_*_*___________________________________ }


		retval = r3_define_table( "T_QAIPPTAB", R3_TYPC, self.A1_base.smidi_qirf[self.qmidi_object].QAIPP )

		IF (SMIDI_NORMAL = retval) THEN
			retval = r3_define_table( "T_QIERRTAB", R3_TYPC, self.A1_base.smidi_qirf[self.qmidi_object].QIERR )
		ENDIF

		IF (SMIDI_NORMAL = retval) THEN

			retval = r3_call( "QIRF_INSPPOINT_GETLIST" )
	
			IF (SMIDI_NORMAL = retval) THEN
				retval = r3_get_table( "T_QAIPPTAB", self.operations )
			ENDIF

			IF (SMIDI_NORMAL = retval) THEN
				retval = r3_get_table( "T_QIERRTAB", self.errors )
			ENDIF

			spare = r3_cleanup_call( )
			IF (SMIDI_NORMAL = retval) THEN
				retval = spare
			ENDIF

		ENDIF
	ENDIF

	return( retval )

ENDROUTINE  { alt_idi_QIRF_INSPPOINT_GETLIST }

{*******************************************************************************}
ROUTINE do_message ( VALUE tmpString, VALUE msg_Level )

{Invoke the Background functionalilty.
*
* Parameters   : theProcess - the Name of the Background Process
*              
* Return Value : None
*
*******************************************************************************}

	DECLARE msg, status

	msg = NOW:" | ":msg_level:" | ":tmpString

	IF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN

		window_set_status ( tmpString )

	ELSE

		LOGMESSAGE "LOGFILE", msg, status

	ENDIF
	
ENDROUTINE { do_message }	

{ $smidi_lib_SAP }
